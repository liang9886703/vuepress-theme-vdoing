<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>分布式架构 | 松垮垮</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="后端开发等技术文章。">
    <meta name="keywords" content="后端博客,个人技术博客,后端,后端开发,后端框架,后端面试题,技术文档,学习,面试,c++,git,github">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.4229948e.css" as="style"><link rel="preload" href="/assets/js/app.41210a84.js" as="script"><link rel="preload" href="/assets/js/2.ddcc22d9.js" as="script"><link rel="preload" href="/assets/js/3.9a514af0.js" as="script"><link rel="preload" href="/assets/js/18.693f6f3c.js" as="script"><link rel="prefetch" href="/assets/js/10.c5ea2586.js"><link rel="prefetch" href="/assets/js/11.345c12e4.js"><link rel="prefetch" href="/assets/js/12.7bd611a3.js"><link rel="prefetch" href="/assets/js/13.e31f4e59.js"><link rel="prefetch" href="/assets/js/14.6cd7ac12.js"><link rel="prefetch" href="/assets/js/15.9d43ec16.js"><link rel="prefetch" href="/assets/js/16.96ef5845.js"><link rel="prefetch" href="/assets/js/17.930177fa.js"><link rel="prefetch" href="/assets/js/19.e757fc80.js"><link rel="prefetch" href="/assets/js/20.ed5c437a.js"><link rel="prefetch" href="/assets/js/21.c41265c1.js"><link rel="prefetch" href="/assets/js/22.ed241c46.js"><link rel="prefetch" href="/assets/js/23.7a084215.js"><link rel="prefetch" href="/assets/js/24.2e695667.js"><link rel="prefetch" href="/assets/js/25.3a8e1528.js"><link rel="prefetch" href="/assets/js/26.a630eff6.js"><link rel="prefetch" href="/assets/js/27.a26a85aa.js"><link rel="prefetch" href="/assets/js/28.532ed3b7.js"><link rel="prefetch" href="/assets/js/29.fa09431b.js"><link rel="prefetch" href="/assets/js/30.0fbcfcdc.js"><link rel="prefetch" href="/assets/js/31.b7ca18e2.js"><link rel="prefetch" href="/assets/js/32.51e3797a.js"><link rel="prefetch" href="/assets/js/33.c79407e6.js"><link rel="prefetch" href="/assets/js/34.c1709f1a.js"><link rel="prefetch" href="/assets/js/35.a1680b5b.js"><link rel="prefetch" href="/assets/js/36.4692c6d1.js"><link rel="prefetch" href="/assets/js/37.1caefdec.js"><link rel="prefetch" href="/assets/js/38.158e350f.js"><link rel="prefetch" href="/assets/js/39.a64bf6b9.js"><link rel="prefetch" href="/assets/js/4.ce7d70a4.js"><link rel="prefetch" href="/assets/js/40.def4302a.js"><link rel="prefetch" href="/assets/js/41.d8026554.js"><link rel="prefetch" href="/assets/js/42.496b6914.js"><link rel="prefetch" href="/assets/js/43.67cc445d.js"><link rel="prefetch" href="/assets/js/44.3f5aa743.js"><link rel="prefetch" href="/assets/js/45.ea91ad4f.js"><link rel="prefetch" href="/assets/js/46.80d186c9.js"><link rel="prefetch" href="/assets/js/47.ecf0e135.js"><link rel="prefetch" href="/assets/js/48.001b8a90.js"><link rel="prefetch" href="/assets/js/49.7d13e977.js"><link rel="prefetch" href="/assets/js/5.a0af7f8a.js"><link rel="prefetch" href="/assets/js/50.c78d144d.js"><link rel="prefetch" href="/assets/js/51.d0c87914.js"><link rel="prefetch" href="/assets/js/52.11fa1467.js"><link rel="prefetch" href="/assets/js/53.f05510d9.js"><link rel="prefetch" href="/assets/js/54.5800936b.js"><link rel="prefetch" href="/assets/js/55.ffc15fea.js"><link rel="prefetch" href="/assets/js/56.88e0791b.js"><link rel="prefetch" href="/assets/js/57.86abaef0.js"><link rel="prefetch" href="/assets/js/58.ccb34ddc.js"><link rel="prefetch" href="/assets/js/59.39016f6c.js"><link rel="prefetch" href="/assets/js/6.2205d704.js"><link rel="prefetch" href="/assets/js/7.6ae52fc4.js"><link rel="prefetch" href="/assets/js/8.8a6895b8.js"><link rel="prefetch" href="/assets/js/9.10468b6d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4229948e.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="松垮垮" class="logo"> <span class="site-name can-hide">松垮垮</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="quicker" class="dropdown-title"><a href="/01/" class="link-title">quicker</a> <span class="title" style="display:none;">quicker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01/01/" class="nav-link">vim.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><a href="/02/" class="link-title router-link-active">分布式</a> <span class="title" style="display:none;">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02/01/" class="nav-link">一致性算法.md</a></li><li class="dropdown-item"><!----> <a href="/02/02/" class="nav-link">分布式ID生成.md</a></li><li class="dropdown-item"><!----> <a href="/02/03/" aria-current="page" class="nav-link router-link-exact-active router-link-active">分布式架构.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/03/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03/01/" class="nav-link">css.md</a></li><li class="dropdown-item"><!----> <a href="/03/02/" class="nav-link">html.md</a></li><li class="dropdown-item"><!----> <a href="/03/03/" class="nav-link">JavaScript.md</a></li><li class="dropdown-item"><!----> <a href="/03/04/" class="nav-link">vue.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统" class="dropdown-title"><a href="/04/" class="link-title">操作系统</a> <span class="title" style="display:none;">操作系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/04/01/" class="nav-link">内存管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/02/" class="nav-link">文件系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/03/" class="nav-link">硬件结构.md</a></li><li class="dropdown-item"><!----> <a href="/04/04/" class="nav-link">网络系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/05/" class="nav-link">设备管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/06/" class="nav-link">调试技术.md</a></li><li class="dropdown-item"><!----> <a href="/04/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/05/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/05/01/" class="nav-link">redis原理.md</a></li><li class="dropdown-item"><!----> <a href="/05/02/" class="nav-link">数据库.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="服务器开发" class="dropdown-title"><a href="/06/" class="link-title">服务器开发</a> <span class="title" style="display:none;">服务器开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06/01/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/06/02/" class="nav-link">nginx环境+编译+调试.md</a></li><li class="dropdown-item"><!----> <a href="/06/03/" class="nav-link">高性能linux服务器.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络编程" class="dropdown-title"><a href="/07/" class="link-title">网络编程</a> <span class="title" style="display:none;">网络编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/07/01/01/" class="nav-link">IP</a></li><li class="dropdown-item"><!----> <a href="/07/02/" class="nav-link">网络工具.md</a></li><li class="dropdown-item"><!----> <a href="/07/03/" class="nav-link">网络编程.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/08/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/08/01/" class="nav-link">GPU并行编程.md</a></li><li class="dropdown-item"><!----> <a href="/08/02/" class="nav-link">mysql.md</a></li><li class="dropdown-item"><!----> <a href="/08/03/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/08/04/" class="nav-link">redis.md</a></li><li class="dropdown-item"><!----> <a href="/08/05/" class="nav-link">网络.md</a></li><li class="dropdown-item"><!----> <a href="/08/06/" class="nav-link">计算机视觉.md</a></li><li class="dropdown-item"><!----> <a href="/08/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目bug" class="dropdown-title"><a href="/09/" class="link-title">项目bug</a> <span class="title" style="display:none;">项目bug</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09/01/" class="nav-link">linux调试.md</a></li><li class="dropdown-item"><!----> <a href="/09/02/" class="nav-link">【Python】：re.error bad escape i at position 4.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/liang9886703" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103123203.jpg"> <div class="blogger-info"><h3>松垮垮</h3> <span>c++后端开发工程师</span> <span></span> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="quicker" class="dropdown-title"><a href="/01/" class="link-title">quicker</a> <span class="title" style="display:none;">quicker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01/01/" class="nav-link">vim.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><a href="/02/" class="link-title router-link-active">分布式</a> <span class="title" style="display:none;">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02/01/" class="nav-link">一致性算法.md</a></li><li class="dropdown-item"><!----> <a href="/02/02/" class="nav-link">分布式ID生成.md</a></li><li class="dropdown-item"><!----> <a href="/02/03/" aria-current="page" class="nav-link router-link-exact-active router-link-active">分布式架构.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/03/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03/01/" class="nav-link">css.md</a></li><li class="dropdown-item"><!----> <a href="/03/02/" class="nav-link">html.md</a></li><li class="dropdown-item"><!----> <a href="/03/03/" class="nav-link">JavaScript.md</a></li><li class="dropdown-item"><!----> <a href="/03/04/" class="nav-link">vue.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统" class="dropdown-title"><a href="/04/" class="link-title">操作系统</a> <span class="title" style="display:none;">操作系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/04/01/" class="nav-link">内存管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/02/" class="nav-link">文件系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/03/" class="nav-link">硬件结构.md</a></li><li class="dropdown-item"><!----> <a href="/04/04/" class="nav-link">网络系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/05/" class="nav-link">设备管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/06/" class="nav-link">调试技术.md</a></li><li class="dropdown-item"><!----> <a href="/04/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/05/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/05/01/" class="nav-link">redis原理.md</a></li><li class="dropdown-item"><!----> <a href="/05/02/" class="nav-link">数据库.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="服务器开发" class="dropdown-title"><a href="/06/" class="link-title">服务器开发</a> <span class="title" style="display:none;">服务器开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06/01/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/06/02/" class="nav-link">nginx环境+编译+调试.md</a></li><li class="dropdown-item"><!----> <a href="/06/03/" class="nav-link">高性能linux服务器.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络编程" class="dropdown-title"><a href="/07/" class="link-title">网络编程</a> <span class="title" style="display:none;">网络编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/07/01/01/" class="nav-link">IP</a></li><li class="dropdown-item"><!----> <a href="/07/02/" class="nav-link">网络工具.md</a></li><li class="dropdown-item"><!----> <a href="/07/03/" class="nav-link">网络编程.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/08/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/08/01/" class="nav-link">GPU并行编程.md</a></li><li class="dropdown-item"><!----> <a href="/08/02/" class="nav-link">mysql.md</a></li><li class="dropdown-item"><!----> <a href="/08/03/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/08/04/" class="nav-link">redis.md</a></li><li class="dropdown-item"><!----> <a href="/08/05/" class="nav-link">网络.md</a></li><li class="dropdown-item"><!----> <a href="/08/06/" class="nav-link">计算机视觉.md</a></li><li class="dropdown-item"><!----> <a href="/08/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目bug" class="dropdown-title"><a href="/09/" class="link-title">项目bug</a> <span class="title" style="display:none;">项目bug</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09/01/" class="nav-link">linux调试.md</a></li><li class="dropdown-item"><!----> <a href="/09/02/" class="nav-link">【Python】：re.error bad escape i at position 4.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/liang9886703" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/02/01/" class="sidebar-link">一致性算法</a></li><li><a href="/02/02/" class="sidebar-link">分布式ID生成</a></li><li><a href="/02/03/" aria-current="page" class="active sidebar-link">分布式架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/02/03/#gossip协议" class="sidebar-link">gossip协议</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#cap理论" class="sidebar-link">CAP理论</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#base理论" class="sidebar-link">BASE理论</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#分布式事务解决方案" class="sidebar-link">分布式事务解决方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#_2pc两阶段提交" class="sidebar-link">2pc两阶段提交</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#_2pc解决方案-xa方案" class="sidebar-link">2pc解决方案——XA方案</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#_2pc解决方案-seata开源项目的at模式" class="sidebar-link">2pc解决方案——Seata开源项目的AT模式</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#tcc事务" class="sidebar-link">TCC事务</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#_3pc三阶段提交" class="sidebar-link">3pc三阶段提交</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#saga模式" class="sidebar-link">saga模式</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#异步消息" class="sidebar-link">异步消息</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#本地消息表方案" class="sidebar-link">本地消息表方案</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#不支持事务的消息队列方案" class="sidebar-link">不支持事务的消息队列方案</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#支持事务的消息队列方案" class="sidebar-link">支持事务的消息队列方案</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#负载均衡概念" class="sidebar-link">负载均衡概念</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#负载均衡的常用策略" class="sidebar-link">负载均衡的常用策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#轮询" class="sidebar-link">轮询</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#最小连接数" class="sidebar-link">最小连接数</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#加权轮询" class="sidebar-link">加权轮询</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#最快响应" class="sidebar-link">最快响应</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#hash法" class="sidebar-link">hash法</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#健康探测" class="sidebar-link">健康探测</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#负载均衡的实现" class="sidebar-link">负载均衡的实现</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#负载均衡集群的实现" class="sidebar-link">负载均衡集群的实现</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#负载均衡的弊端" class="sidebar-link">负载均衡的弊端</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#固定窗口" class="sidebar-link">固定窗口</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#滑动窗口" class="sidebar-link">滑动窗口</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#漏桶算法" class="sidebar-link">漏桶算法</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#令牌算法" class="sidebar-link">令牌算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#单桶单速" class="sidebar-link">单桶单速</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#单速双桶" class="sidebar-link">单速双桶</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#双速双桶" class="sidebar-link">双速双桶</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#分布式系统中做限流" class="sidebar-link">分布式系统中做限流</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#回滚" class="sidebar-link">回滚</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#重试" class="sidebar-link">重试</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#有状态和无状态" class="sidebar-link">有状态和无状态</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#高内聚低耦合" class="sidebar-link">高内聚低耦合</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#弹性架构" class="sidebar-link">弹性架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#事件驱动架构" class="sidebar-link">事件驱动架构</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#中心化模式" class="sidebar-link">中心化模式</a></li><li class="sidebar-sub-header level4"><a href="/02/03/#去中心化模式" class="sidebar-link">去中心化模式</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#微内核架构" class="sidebar-link">微内核架构</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#拆库" class="sidebar-link">拆库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#拆库之前" class="sidebar-link">拆库之前</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#垂直拆分" class="sidebar-link">垂直拆分</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#水平拆分" class="sidebar-link">水平拆分</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#常见的缓存更新策略" class="sidebar-link">常见的缓存更新策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#cache-aside-旁路缓存-策略" class="sidebar-link">Cache Aside（旁路缓存）策略</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#read-write-through-读穿-写穿-策略" class="sidebar-link">Read/Write Through(读穿/写穿)策略</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#write-back-写回-策略" class="sidebar-link">Write Back（写回）策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/02/03/#本地缓存和分布式缓存" class="sidebar-link">本地缓存和分布式缓存</a></li><li class="sidebar-sub-header level2"><a href="/02/03/#缓存带来的一些问题" class="sidebar-link">缓存带来的一些问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/02/03/#缓存雪崩" class="sidebar-link">缓存雪崩</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#缓存击穿" class="sidebar-link">缓存击穿</a></li><li class="sidebar-sub-header level3"><a href="/02/03/#缓存穿透" class="sidebar-link">缓存穿透</a></li></ul></li></ul></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/02/#分布式" data-v-06970110>分布式</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/liang9886703" target="_blank" title="作者" class="beLink" data-v-06970110>songkuakua</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">分布式架构<!----></h1>  <div class="theme-vdoing-content content__default"><p><a href="https://www.cnblogs.com/Zachary-Fan/p/distributedsystems.html" target="_blank" rel="noopener noreferrer"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="共识算法"><a href="#共识算法" class="header-anchor">#</a> 共识算法</h1> <h2 id="gossip协议"><a href="#gossip协议" class="header-anchor">#</a> gossip协议</h2> <p>[gossip协议]（https://cloud.tencent.com/developer/article/1662250）</p> <p>[todo——gossip协议]（https://blog.csdn.net/u012422440/article/details/110571640）</p> <h1 id="分布式事务"><a href="#分布式事务" class="header-anchor">#</a> 分布式事务</h1> <h2 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h2> <ol><li>跨JVM进程，例如微服务架构</li> <li>跨数据库实例，一次操作涉及不同数据库</li> <li>涉及同步互斥的多服务访问同一个数据库</li></ol> <h2 id="cap理论"><a href="#cap理论" class="header-anchor">#</a> CAP理论</h2> <ul><li>C(Consistency) 一致性，在同一时间读取任何一台机器得到的数据是一致的，读写操作是串行化的</li> <li>A(Availability)可用性，任何读写操作都可以读到结果，不会超时</li> <li>P(partition tolerance)分区容忍，集群中存在两个或多个子网之间不能相互通信，而集群依然可以对外提供服务</li></ul> <p>在开发中，p通常都会出现，而C和A不能同时满足</p> <p>AP：业务如果可以接受最终一致性，短时间内查到的数据不是最新的，例如redis，</p> <p>CP: 追求强一致性同时放弃一部分性能，通常适用于小规模的数据，例如zookeeper,etcd</p> <p>CA: 不分区的系统不是一个标准的分布式系统</p> <p>实际开发中，很少有系统是纯粹的AP或CP，需要根据业务权衡</p> <h2 id="base理论"><a href="#base理论" class="header-anchor">#</a> BASE理论</h2> <p>BASE理论是对AP的拓展的</p> <ul><li>BA(basically available) 基本可用,当系统出现故障的时候保证基本功能可用，损失部分可用功能</li> <li>S(soft state)软状态，在数据写入成功和失败之间存在一个中间状态，“支付中”，“等待中”</li> <li>E(eventually consistent)最终一致性，当前的数据可能不是一致性的，但在有限的时间后，数据会达成一致</li></ul> <h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="header-anchor">#</a> 分布式事务解决方案</h2> <p>2pc、3pc、tcc都引入了事务的决策者这个身份，可靠消息最终一致性，最大努力通知</p> <h3 id="_2pc两阶段提交"><a href="#_2pc两阶段提交" class="header-anchor">#</a> 2pc两阶段提交</h3> <p>一阶段，事务管理者给每个参加者发送消息，每个参与者本地上锁执行事务，并回复</p> <p>二阶段，如果所有事务参与者都回复了成功，则事务管理者发送提交，事务参与者之前写入的数据此时生效使用。如果有事务参与者回复事务执行失败，则事务管理者发送回滚，事务参与者回退之前执行的事务</p> <blockquote><p>两阶段提交和raft
raft是一种一致性算法，从底层通过日志复制确保多个节点数据一致，日志只会增加不会有删除
两阶段提交是分布式事务，属于业务逻辑，确保多个机器执行同样的增删改查操作
两阶段是一种实现分布式事务的方式，分布式事务也可以通过raft来实现，例如etcd</p></blockquote> <p>oracle、mysql都支持2pc协议</p> <h4 id="_2pc解决方案-xa方案"><a href="#_2pc解决方案-xa方案" class="header-anchor">#</a> 2pc解决方案——XA方案</h4> <p>2PC是数据库层面实现的，XA方案提供了分布式事务处理模型DTP（Distributed Transaction Processing Reference Model），提供了如下角色</p> <ul><li>AP，应用程序</li> <li>TM，事务管理器，嵌入AP中，协调各个RM</li> <li>RM，资源管理器，事务的参与者</li></ul> <p>TM向AP提供应用程序编程接口，AP通过TM提交及回滚事务，TM中间件通过XA接口来通知RM事务的执行</p> <p>执行的逻辑和2pc是一样的，只是定义了TM和RM之间的通讯接口规范XA，基于XA协议来实现的2PC叫XA方案</p> <h4 id="_2pc解决方案-seata开源项目的at模式"><a href="#_2pc解决方案-seata开源项目的at模式" class="header-anchor">#</a> 2pc解决方案——Seata开源项目的AT模式</h4> <p>一个开源的分布式事务框架，提供AT模式（即2pc）和TCC模式的分布式解决方案</p> <p>组成：</p> <ul><li>TC(transaction coordinator):事务协调器，需要独立部署，接收TM发起的事务，向RM协调各分支事务</li> <li>TM(transaction manager):事务管理器，嵌入应用程序中，负责开启一个全局事务，向TC发起事务的提交或回滚</li> <li>RM(resource manager):控制分支事务，接收TC的指令，驱动本地事务的提交和回滚</li></ul> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/./image2.png" alt=""></p> <p><strong>seata的AT模式比起传统的2pc</strong>：将全局事务拆分成了多个子分支事务执行，比起2PC在二阶段提交时才释放锁，seata在一阶段就将本地事务提交并释放锁，提高了效率</p> <blockquote><p>seata中的RM配合数据库通过undo log引入了mvcc的部分机制，分支事务的执行实际上是写入了undo log之中。</p></blockquote> <h3 id="tcc事务"><a href="#tcc事务" class="header-anchor">#</a> TCC事务</h3> <p>TCC要求每个分支事务提供预处理（Try）、确认（conrm）、撤销（cancel）三个操作，接入时每个分支事务都需要实现这三个接口。要保障这三个接口本身执行不会中断和出错，且具有幂等（因为conrm和cancel失败可能会重试）</p> <ul><li>try阶段做业务检查及资源预留</li> <li>conrm阶段做确认提交</li> <li>cancel阶段是业务执行出错需要回滚时执行</li></ul> <p>整体依然由TC、TM、RM组成，TM可以是独立的服务，也可以让TC充当TM的角色。首先，TM发起分支的try操作，如果有分支try操作失败则发起cancel操作，如果try操作全部执行成功，则发起所有分支事务的conrm操作，conrm和cancel操作可能执行多次</p> <p><strong>Seata的TCC模式，比起AT模式</strong>：</p> <ul><li>接入：AT模式需要数据库支持，TCC模式需要实现TCC三个接口，接入成本更高</li> <li>事务回滚：AT模式通过记录undo log和redo log从而自动在事务回滚时回复数据，TCC模式事务执行失败，需要调用cancel接口来回复数据</li> <li>适用业务：AT模式适用于支持事务的数据库，TCC模式适用更复杂灵活的业务场景，可以精细控制每个服务或操作的补偿逻辑，降低锁冲突，提高吞吐</li></ul> <p><strong>几个TCC模式下的异常</strong></p> <p><strong>空回滚</strong>：需要能识别出没有调用try就调用了cancel方法（用全局事务ID记录整个事务的生命周期）</p> <p><strong>幂等</strong>：当cancel或conrm操作重试时不会导致数据不一致（在分支事务中增加执行状态）</p> <p><strong>悬挂</strong>：二阶段的cancel比try接口先执行，try接口预留了资源此时无法释放和使用（全局事务判断如果有二阶段事务执行了，不执行try）</p> <h3 id="_3pc三阶段提交"><a href="#_3pc三阶段提交" class="header-anchor">#</a> 3pc三阶段提交</h3> <p>引入了超时机制和新的询问阶段</p> <ul><li>cancommit阶段：询问</li> <li>precommit阶段：cancommit阶段所有cohort都回复yes，则锁资源，发送所有cohort预提交，记录undo和redo日志。否则发送事务中断</li> <li>docommit阶段：向所有cohort发送提交，cohort执行提交并相应，所有cohort响应后coordinator完成事务。存在cohort回复no响应或超时未响应，发送中断请求</li></ul> <p>比起2pc：</p> <ul><li>缩小协调者单点故障带来的影响：2pc如果协调者的消息丢失，执行者的资源会一直上锁无法释放。3pc当进行到precommit阶段后，如果协调者的docommit消息或abort消息迟迟未到，执行者可以自行决定是回退还是提交。</li> <li>数据不一致：docommit阶段执行者发送出abort回退，有些执行者收到了并执行，有些没有收到超时主动默认执行commit（）</li> <li>新增一个阶段作为缓冲，cancommit阶段先看能不能执行，不能执行就abort不占用资源</li></ul> <h3 id="saga模式"><a href="#saga模式" class="header-anchor">#</a> saga模式</h3> <p><strong>编排模式：</strong></p> <p>发起者调用第一个事务的参与者，其执行子事务后调用事务链的下一个参与者，最后一个参与者完成后再通知事务的发起者，完成整个事务。如果中间某个子事务执行失败，链式回复链路的上一个参与者进行补偿操作。</p> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/image4.png" alt=""></p> <p><strong>控制模式</strong>：</p> <p>发起者向saga协调器发送请求命令，协调器按照子事务的执行顺序链式调用每个服务，即引入了一个第三方来控制链式调用</p> <p><strong>两个模式的区别</strong>：</p> <p>编排模式实现更简单，但整个链路不可控，也不好查看。</p> <p>控制模式存在一个saga协调器来管理这个链式调用，可以在协调器里看到这个调用逻辑，实现统一细化控制链式操作，判断是否存在循环调用等等，并且可以对部分场景从链式调用优化为并行调用，是商业上更成熟的方案</p> <p><strong>比起TCC模式</strong>：</p> <ul><li>场景：saga适用于业务流程长的场景。TCC需要业务支持，对于无法修改的微服务可以采用saga模式。例如金融系统（需要对接外部系统，流程长）</li> <li>接入：TCC里try阶段预留资源，conrm阶段和cancel阶段都需要单独编写接口，接入相对复杂。saga模式提供执行和补偿操作的接口相对容易实现（订单创建对应删除，修改数据对应删除，都是业务逻辑）</li> <li>一致性：链式执行的saga意味着分布式执行的速度会更慢，且每个节点执行了子事务后数据不一致就出现了，整个系统数据不一致更突出</li></ul> <h3 id="异步消息"><a href="#异步消息" class="header-anchor">#</a> 异步消息</h3> <p>事务发起方执行完本地事务并发出后，就认为事务处理成功了。</p> <ul><li>要求发送方本地事务的执行和消息发送共同构成原子性操作，</li> <li>接收方消费消息的幂等性，可以重复接收消息但不会重复执行消息</li></ul> <p>特点：不同服务间解耦度高，相对执行周期长，将同步的事务操作变成了异步的消息执行。不考虑接收方事务是否执行成功</p> <h4 id="本地消息表方案"><a href="#本地消息表方案" class="header-anchor">#</a> 本地消息表方案</h4> <p>将消息存储在和本地数据同一个数据库中，对本地数据的读写和对消息的读写都经过本地数据库的同一个事务，从而保证对消息和数据的写入的原子性。后台线程定期读取消息文件发送到接收方。</p> <p>对于接收方：</p> <p><strong>可靠消息最终一致性</strong>：</p> <p>发送方持续发送消息，直到接收方回复ack表示消费了消息</p> <p><strong>最大努力通知</strong>：</p> <p>发送方按照一定策略周期性发送消息（例如1min、2min、4min……），接收方如果要使用这个数据，主动向发送方请求同步数据</p> <p>特点：解决了发送方消息发送和事务执行的原子性，但接收方需要保证消费消息这个操作是幂等的，适用于实时性要求不高的场景，有比较好的吞吐量</p> <h4 id="不支持事务的消息队列方案"><a href="#不支持事务的消息队列方案" class="header-anchor">#</a> 不支持事务的消息队列方案</h4> <p>比起本地消息表方案，发送方只需要将消息交付消息中间件，由消息中间件通知接收方。</p> <p>不需要发送方轮询发送消息，需要解决发送方事务执行和消息发送的原子性</p> <h4 id="支持事务的消息队列方案"><a href="#支持事务的消息队列方案" class="header-anchor">#</a> 支持事务的消息队列方案</h4> <p>消息队列提供了收到消息的通知发送方执行事务，发送方执行事务成功后再通知发送的能力</p> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/./image3.png" alt=""></p> <p>[saga分布式事务]（https://cloud.tencent.com/developer/article/1839642）</p> <p>[infoQ——支持分布式事务的消息中间件rocketMQ]（https://www.infoq.cn/news/2018/08/rocketmq-4.3-release）</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;mid=2247483888&amp;idx=1&amp;sn=b1d565c57198b98e3ab73a886697bfe0&amp;chksm=fca315eacbd49cfcd06bace206cc73afa31f8421d249fe5cbfc06fa5bbf1d80373c4e5e8c009&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">分布式系统——事务<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://baijiahao.baidu.com/s?id=1717325036148461851&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener noreferrer">百家号——分布式事务<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY5NDU2Ng==&amp;mid=2651851463&amp;idx=1&amp;sn=8d7863f332a9c0e4827413d6959eef47&amp;chksm=80494f8eb73ec69835550663b718664859baaff66de0c40b0ea07f3ce11b06a12f77f86bcdce&amp;scene=27" target="_blank" rel="noopener noreferrer">三阶段提交<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="高可用-负载均衡"><a href="#高可用-负载均衡" class="header-anchor">#</a> 高可用-负载均衡</h1> <h2 id="负载均衡概念"><a href="#负载均衡概念" class="header-anchor">#</a> 负载均衡概念</h2> <p>负载均衡的使用场景</p> <ul><li>web应用负载均衡，将用户请求分发到不同的web服务器</li> <li>数据库负载均衡，对于大量的数据库查询、事务操作负载均衡</li> <li>应用服务负载均衡</li> <li>云计算负载均衡，服务在云中不同实例之间分发流量</li></ul> <p>不同的负载均衡</p> <ul><li>7层负载均衡：使用URL（http）或api（quic）接收外部流量</li> <li>4层负载均衡：使用IP+端口（tcp、udp）接收外部流量</li> <li>3层负载均衡：使用虚拟IP地址（公共ip）访问，映射为实际的ip地址（私有ip）</li> <li>2层负载均衡：使用虚拟MAC地址请求实际机器，修改为目的地的mac地址，使真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一样，这种方式为直径路由方式（DR方式）</li></ul> <blockquote><p>2层和3层负载均衡不会同时使用，通常在硬件确定的局域网中通信时使用2层LVS更高效，3层局域网需要做ip地址的转化有轻微的性能开销</p></blockquote> <blockquote><p>3层负载均衡比起4层，性能高但功能单一，只关注ip包的传输，适用于大规模流量调度，4层负载均衡支持更细颗粒度的流量分发，适用于应用服务</p></blockquote> <h2 id="负载均衡的常用策略"><a href="#负载均衡的常用策略" class="header-anchor">#</a> 负载均衡的常用策略</h2> <h3 id="轮询"><a href="#轮询" class="header-anchor">#</a> 轮询</h3> <p>嗯。。</p> <h3 id="最小连接数"><a href="#最小连接数" class="header-anchor">#</a> 最小连接数</h3> <p>嗯。。。</p> <h3 id="加权轮询"><a href="#加权轮询" class="header-anchor">#</a> 加权轮询</h3> <p><strong>简单的实现</strong></p> <p>如果3台机器的权重是2 1 2：
每次请求到来按照机器1，机器1，机器2，机器3，机器3，这样的顺序分配</p> <p>问题：如果运行时通过配置reload服务来增加机器或修改了当前机器的权重，那么整个负载的过程要重新开始，当前机器已经接收的服务无法作为负载均衡的参考因素</p> <p><strong>更成熟的实现方式</strong></p> <p>如下的实现，由（当前节点的权重值，已提供服务的历史权重，整个集群的权重）共同决定节点当前的权重</p> <h3 id="最快响应"><a href="#最快响应" class="header-anchor">#</a> 最快响应</h3> <p>记录最近一段时间的请求耗时的平均值作为权重，结合加权轮询</p> <h3 id="hash法"><a href="#hash法" class="header-anchor">#</a> hash法</h3> <p>前面都是根据服务端的能力负载均衡，hash是将客户端的请求尽可能打散分摊到不同机器，降低一个机器负载过高的概率，不能完全解决负载均衡，可以和其他方案搭配使用</p> <h3 id="健康探测"><a href="#健康探测" class="header-anchor">#</a> 健康探测</h3> <p>通过健康探测判断机器是否可用，不可用可以将节点临时移出服务列表</p> <p><strong>http探测</strong>：用get\post请求某个url，通过http状态码来判断</p> <p><strong>tcp探测</strong>：三次握手+rst来中断连接</p> <p><strong>udp探测</strong>：icmp协议提供的探测能力</p> <h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="header-anchor">#</a> 负载均衡的实现</h2> <p><strong>域名解析实现负载均衡</strong></p> <p>一些公司会搭建DNSHTTP，可以用它用作内网的ip解析，动态返回不同ip起到负载均衡，但DNS工作在网络层，无法对端口均衡</p> <p><strong>硬件负载均衡</strong></p> <p>如果资金大于时间时，硬件负载均衡（例如F5）能同时支持L2-L7的转发，在服务器和外部网络之间安装负载均衡设备，独立于操作系统，功能强大，这里主要提软件负载均衡</p> <p><strong>L7层负载均衡</strong>：</p> <p>场景：当用户规模扩大后，通常应用比数据库先到达瓶颈，将单应用-单库变成多应用-单库。</p> <p>解决方案:</p> <ul><li>反向代理（成熟的产品有用nginx或HAProxy）：公网域名解析解析到反向代理的机器，反向代理负责将请求转发到web应用的IP+端口和做负载均衡策略（nginx默认轮询策略）</li> <li>api网关：在微服务架构中，微服务的调用都会经过api网关做统一的路由选择、限流、安全策略等</li> <li>重定向负载均衡：
用户请求到达重定向服务器，返回302状态码和重定向服务器地址，再访问实际服务器，浏览器需要两次请求才能完成访问性能不好，不常用</li></ul> <blockquote><p>反向代理和api网关是指的不同功能，在成熟的架构中，一个nginx能同时实现这两个功能，对于http类型的请求走反向代理，对于api方式的访问走api网关的路由方式</p></blockquote> <p><strong>L4层负载均衡</strong></p> <p>场景：当应用所依赖的服务需要横向拓展时，例如分表、缓存、主从集群等。</p> <p>通过3层的VIP地址加4层的端口号决定处理哪些流量，对流量进行nat处理转发到后台服务器，并记录，后续的这个连接的流量都转发到同一台机器</p> <p>解决方案：</p> <ol><li>LVS是一个支持L4的负载均衡软件，位于linux内核，比起nginx做L4在性能上会更优</li></ol> <p>处理4层IP+端口的流量，底层的实现有NAT模式，TUN模式，DR模式</p> <ol start="2"><li>F5：硬件方案，成本高，但功能最好</li> <li>nginx</li> <li>HAProxy，一个高性能的负载均衡器，</li></ol> <p>原理：客户端的请求首先到达HAProxy，HAProxy通过定期向每个后端nginx节点做健康检查，维持一个可用的负载均衡池</p> <p>作为L4负载均衡器，适用于后端有大量的nginx节点，需要做更复杂的流量分配策略</p> <p><strong>客户端负载均衡</strong></p> <p>将服务清单放到客户端中。客户端通过服务注册定期更新每个服务对应的instance清单，访问时直接本地服务发现访问指定实例</p> <p>优点是可以避免负载均衡器的单点故障</p> <h2 id="负载均衡集群的实现"><a href="#负载均衡集群的实现" class="header-anchor">#</a> 负载均衡集群的实现</h2> <p><strong>如何实现故障转移和高可用：</strong></p> <p>Keepalived，一个用于高可用的软件，原理：</p> <ul><li>外部流量始终指向vip，</li> <li>将nginx节点划分为master节点、backup节点，默认行为是只由master节点提供服务，backup不服务（这样的设计是因为Keepalived只用来保证集群的高可用，不负责负载均衡）</li> <li>Keepalived随nginx部署，不同节点的后台keepalived协同工作，keepalived通过VRRP感知本地的nginx服务，当主节点故障时，自动将vip切换到备用节点</li></ul> <p>VRRP是一个3层的协议，通过组播和优先级选举机制实现虚拟ip在多个节点之间漂移。通过4层的网络对不同节点做健康检查</p> <p>多个节点之间用心跳感知集群状态，节点过多时网络资源消耗增大，因此只适用于小规模的集群</p> <p><strong>方案一：Keepalived + HAProxy + Nginx 的组合架构</strong>：将多个HAProxy节点分为若干组，客户端的请求到达先通过DNS、负载均衡硬件或其他手段到达一个HAProxy组，这个组内通过vip访问由Keepalived管理的HAProxy集群中的一个健康节点，HAProxy将流量分发到多个后端nginx节点</p> <p><strong>方案二：Keepalived + KVS + Nginx 的组合架构</strong>：</p> <p>流量到达vip步骤同上，LVS通过keepalived组成集群作4层负载，LVS以DR模式挂nginx做7层负载。如果在同一个局域网内，用DR模式有很好的性能，不在一个局域网用TUN模式进行L3转发。</p> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/./image5.png" alt=""></p> <p><strong>方案三：HAProxy配合容器编排工具</strong>：在容器化中运行HAProxy为一个服务，通过k8s自带的负载均衡实现高可用。部署简单，适用于云原生架构</p> <blockquote><p>其他一个集群服务基本的功能，包括对nginx集群的日志收集、警报机制、性能监控，配置管理（为了让一个集群里不同机器根据自身的硬件能力使用不同的配置，以及实现灰度发布功能）</p></blockquote> <h2 id="负载均衡的弊端"><a href="#负载均衡的弊端" class="header-anchor">#</a> 负载均衡的弊端</h2> <p><strong>session丢失问题</strong>：负载均衡的hash算法决定了当机器不变时，可以让一个用户的请求每次都被同一个机器响应，但是当机器增加后，可能导致大量同一用户的请求被分配到新的机器处理，而新的机器上没有这个用户的缓存，从而直接访问后端数据库，造成缓存穿透</p> <p>一些解决方案：</p> <ol><li>session保持</li></ol> <p>当用户流量第一次进入nginx匹配节点时，为其生成一个唯一标识写入到cookie中返回给用户，此后用户每次访问时携带这个cookie，nginx将这个用户的请求转发到对应的节点上去。缺点是需要客户端开启cookie机制</p> <p>nginx的nginx-sticky-module模块可以实现这个功能</p> <ol start="2"><li>session复制</li></ol> <p>用户的session信息同步给所有服务机器</p> <p>简单粗暴，数据冗余多，有广播风暴风险，网络带宽消耗大</p> <ol start="3"><li>session共享</li></ol> <p>将session信息放到一个全局共享的存储介质中心化</p> <p>对这个共享介质作水平拓展就能应对用户的增长，拓展性好。但每次读写都要请求共享介质，性能下降。共享介质的维护带来成本。要应对共享介质的单点故障</p> <blockquote><p>每个请求的session信息都以最终一致性的方式同步到共享存储，用户的请求到来时先使用本地的session信息，如果找不到再去共享存储查询。共享存储如果还没同步到数据，则发起主动数据更新请求管理session信息的消息中间件。这个链路会不会太长了？</p></blockquote> <p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;mid=2247483998&amp;idx=1&amp;sn=fd7a0790c8199d400f8c73b99bef6392&amp;chksm=fca31644cbd49f52bb857b270ea832bed389689499d714d41b6df694d5b9a98cc5f38936106b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">分布式系统<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>[知乎，深入理解负载均衡]（https://zhuanlan.zhihu.com/p/5108202387）</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;mid=2247484012&amp;idx=1&amp;sn=f1d66f74ba91e7743e62ad0fa412d741&amp;chksm=fca31676cbd49f6052b302fd49d59f2208160dfc2d22e92998ad34d77666df9d2ca5b94d61a6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">做了「负载均衡」就可以随便加机器了吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="高可用-熔断"><a href="#高可用-熔断" class="header-anchor">#</a> 高可用-熔断</h1> <p>基本功能：识别当前处于不可用状态-&gt;切断联系-&gt;识别当前处于可用状态-&gt;重新恢复服务</p> <p>为避免瞬发的异常，引入时间窗口，在窗口内，通过请求失败的次数或者请求成功和失败的百分比来判定</p> <blockquote><p>如果所依赖的系统有分区或多副本，个别节点的异常不等于所以节点异常
先考虑降级或限流，最后考虑熔断</p></blockquote> <h1 id="高可用-限流"><a href="#高可用-限流" class="header-anchor">#</a> 高可用-限流</h1> <p>首先需要通过压测获得系统能力的上限，通常需要得到两个结果，速率（一个时间单位里处理请求的数量），并发数（同一时刻能处理的最大值）</p> <h2 id="固定窗口"><a href="#固定窗口" class="header-anchor">#</a> 固定窗口</h2> <p>将时间划分为多个固定的周期（10s、30s），计数每个进入到流量，淘汰超过阔值的流量，进入下个周期清零计数器</p> <p>缺点：一个时间周期里流量进入到速度也是有波动的，周期里前1/3是流量高峰已经将计数器占满了，后2/3流量平缓，但却无法提供服务</p> <h2 id="滑动窗口"><a href="#滑动窗口" class="header-anchor">#</a> 滑动窗口</h2> <p>为了解决上述问题，将固定窗口划分成更小的多个窗口，统计的时间范围随时间段推动同步后移。如果固定窗口已经很小了，那么不需要使用滑动窗口</p> <p>部分程度上解决了上述问题，依然无法物尽其用</p> <h2 id="漏桶算法"><a href="#漏桶算法" class="header-anchor">#</a> 漏桶算法</h2> <p>当流量速度达到阔值后，先缓存在桶内，桶内按照预先的速度逐渐释放流量，如果流量的速度超过了缓存的能力，则丢弃</p> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/./image6.png" alt=""></p> <p>解决了滑动窗口的问题，但是需要提前预估设置阈值，通常只能设置一个相对悲观的值，但系统的处理能力随时在变化，能承载的流量能力在一个窗口内不是恒定的。</p> <h2 id="令牌算法"><a href="#令牌算法" class="header-anchor">#</a> 令牌算法</h2> <h3 id="单桶单速"><a href="#单桶单速" class="header-anchor">#</a> 单桶单速</h3> <p>令牌桶存放令牌，定期向令牌桶发放一定令牌，流量从令牌桶拿到令牌的才能提供服务</p> <p>适用于优先级较低的业务，如外网HTTP流量</p> <blockquote><p>令牌桶和漏桶的区别：漏桶限制的是流出的流量速度，需要业务方提供最低处理能力即速率作为流出的阔值，令牌桶限制的是流入的流量速度，可以屏蔽业务方处理能力的波动，令牌桶的大小是业务方的最大并发数，在相同参数下得到的限流效果是一样的</p></blockquote> <h3 id="单速双桶"><a href="#单速双桶" class="header-anchor">#</a> 单速双桶</h3> <p>两个令牌桶C、E，使用时先使用C桶的，C桶用完了再用E桶。投放时先投C桶，C桶满了再投E桶</p> <p>比起单桶单速能允许一定程度的突发流量？？？？？</p> <p>使用于有突发的业务，如企业邮件</p> <h3 id="双速双桶"><a href="#双速双桶" class="header-anchor">#</a> 双速双桶</h3> <p>P桶表示最多接收多少个流量，C桶表示最多服务多少个流量。流量进来先去P通拿令牌，没拿到抛弃，再去C桶拿令牌，拿到才提供服务，没拿到等待，即P桶起到一个缓冲的作用，一个流量要被服务需要同时拿到PC桶的令牌。</p> <p>分别以不同速率向P桶、C桶投放令牌</p> <p><a href="https://blog.csdn.net/u012451051/article/details/125715218" target="_blank" rel="noopener noreferrer">令牌算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.sohu.com/a/476287790_445400" target="_blank" rel="noopener noreferrer">令牌算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>固定窗口和滑动窗口适用于作为临时方案，实现简单。漏桶最适合作为通用方案，资源利用上没有那么极致但对保护后端系统有一定的余地。令牌桶用于对后端性能的机制压榨</p> <h2 id="分布式系统中做限流"><a href="#分布式系统中做限流" class="header-anchor">#</a> 分布式系统中做限流</h2> <p>从系统的纵向考虑。在一个分布式系统中，越靠前越容易做限流。如果有接入层，在接入层做（nginx作为反向代理时，ngx_http_limit_conn_module以及ngx_http_limit_req_module模块来做限流）。如果没有接入层那么要考虑不同的应用下，谁优先做限流。</p> <p>从效果上来说，在客户端部分做限流会更高效，但客户端做限流难度更大，成本更高</p> <p>对于多个客户端做限流，或一个服务端集群做限流，每个节点的性能存在差异，且会实时变动，要感知多个节点的能力得到一个策略并在多个节点生效，可以引入一个性能监控平台和配置中心</p> <h1 id="高可用-降级"><a href="#高可用-降级" class="header-anchor">#</a> 高可用-降级</h1> <p>将有限的资源消息最大化，损失一部分功能，将资源让给核心功能，使得核心功能有更强的服务能力</p> <p>一些降级方案：</p> <ol><li>牺牲用户体验：</li></ol> <ul><li>放缓流量速度，增加验证码</li> <li>减少对冷数据的获取，禁止翻页</li> <li>静态化数据代替动态化数据</li> <li>减少计算，提高查询是的筛选要求</li></ul> <ol start="2"><li>牺牲功能完整性
减少日志采集，关闭风控</li> <li>牺牲时效性
异步执行的操作降低处理效率</li></ol> <p>降级对象的选择采用定级定序：将每个功能按照重要程度划分为几个级别，每个级别的每个服务排序。主要服务端依赖关系，被依赖的服务优先级不能低于依赖方</p> <h1 id="高可用-补偿"><a href="#高可用-补偿" class="header-anchor">#</a> 高可用-补偿</h1> <p>在一个传输链路中，任何一环都有可能出错，一旦某个操作发生了异常，可以通过内部机制将这个异常产生的不一致状态消除掉</p> <blockquote><p>事务补偿是做回滚操作，重试也是一种补偿</p></blockquote> <h2 id="回滚"><a href="#回滚" class="header-anchor">#</a> 回滚</h2> <p>显示回滚：首先确定回滚的范围，在编排服务端时候把有回滚接口的服务放到前面，这样后面的工作服务出错时有机会回滚。回滚中间产生的数据可以做存储</p> <p>隐式回滚：即这个回滚动作不需要额外处理，例如超时失效机制，预占机制（用户15分钟没有支付账单，释放库存）</p> <h2 id="重试"><a href="#重试" class="header-anchor">#</a> 重试</h2> <p>当下游系统返回临时状态，有恢复预期的时候可以考虑重试</p> <ul><li>立即重试</li> <li>固定间隔重试</li> <li>增量/指数间隔：失败次数越多的重试请求优先级排到越后面</li> <li>全抖动：在递增的基础上，增加随机性。能将某一时刻的大量请求分散。<code>return random(0, 2^retrycount)</code></li> <li>等抖动：全抖动和增量间取平衡<code>return 2^retrycount + random(0, 2^retrycount)</code></li></ul> <p>重试调用的接口应当具有幂等性：一旦某个功能支持重试，那么整个功能都要考虑幂等性</p> <p>接口实现幂等性的思路：</p> <ul><li>给请求加版本号</li> <li>给处理加上状态</li></ul> <h1 id="高可用-伸缩性"><a href="#高可用-伸缩性" class="header-anchor">#</a> 高可用-伸缩性</h1> <h2 id="有状态和无状态"><a href="#有状态和无状态" class="header-anchor">#</a> 有状态和无状态</h2> <p>一个程序的执行中，对于一些重复的数据获取生成，可以临时记录，形成一种局部的会话状态，目的是为了提高程序的效率，但带来了这次会话对这台机器的依赖问题，导致服务端没法对用户请求进行自由调度，容错性不好，不利于集群的伸缩和维护，这就是有状态。如果想获得好的伸缩性，无状态的处理机制更合适</p> <p>状态信息前置，利用客户端的cookie，将临时数据发给客户端暂存，需要的数据都通过上游的客户端传过来。带来的代价是网络的数据包更大</p> <p>在整个请求链路环节中，对于会话状态相关的处理尽可能的在贴合用户的上层去做，这样状态丢失重建状态的成本相对小很多，且下层的DAL(Data Access Layer)和BLL(Business Logic Layer)代码更易于维护，也易于灰度发布（中心化会话信息，灰度发布下会有用不到的信息创建）</p> <p>通常将IO密集型程序和CPU密集型程序分离才能更好的实现无状态，有状态的部分全部给IO密集型程序，CPU密集型程序从而做到无状态</p> <h2 id="高内聚低耦合"><a href="#高内聚低耦合" class="header-anchor">#</a> 高内聚低耦合</h2> <blockquote><p>内聚度：如果一个模块功能明确单一，组成模块的元素结合的紧密，则内聚度高</p></blockquote> <p>分布式系统中对一个问题需要分解成多个子问题治理，再做归并。对每个子问题需要各自独立，不能相互依赖。</p> <p>首先需要定义好每个模块的职责，其次对模块做功能的归类分层，同时做好每个模块边界的划分。主要依靠codereview和静态代码检测工具，需要关注：</p> <ul><li>检查依赖是否超出规定</li> <li>对类的调用必须通过接口</li> <li>功能是否单一</li> <li>写接口尽可能少的输入参数，读数据返回尽可能多的参数</li></ul> <blockquote><p>写操作为了确保逻辑的准确性，尽可能清晰处理的逻辑
读操作为了应对接收方业务的频繁变动，提前返回尽可能多的数据从而降低改动。更好的方案是通过传入的参数按需返回数据</p></blockquote> <h2 id="弹性架构"><a href="#弹性架构" class="header-anchor">#</a> 弹性架构</h2> <p>在事件驱动架构中，一个请求需要不同的业务功能配合完成</p> <h3 id="事件驱动架构"><a href="#事件驱动架构" class="header-anchor">#</a> 事件驱动架构</h3> <h4 id="中心化模式"><a href="#中心化模式" class="header-anchor">#</a> 中心化模式</h4> <p>存在3类主体：事件生产者、上帝（调停者）、事件处理者</p> <p>在这个架构下的执行逻辑：事件生产者-&gt;队列-&gt;上帝（调停者）-&gt;队列-&gt;事件处理者</p> <p>对于上帝来说，需要做</p> <p><strong>事件转换</strong>：通过一个全局标识表示这个请求，记录事件发起者的入参，通过子标识记录整个事件过程中产生的请求和累积的上下文，例如x.x.x.x格式</p> <p><strong>事件发送</strong>：负责事件流转，决定了是串行执行还是并行，是否产生分支，是否需要归并</p> <p>对于大规模的数据来说，中心化模式能让整个流程更加清晰，也易于监控，复杂度都在调停者这里，事件处理者不需要关系整个流程，易于事件处理的修改，事件流程的变动。但同时也还需要考虑数据一致性，加大实现的复杂度</p> <h4 id="去中心化模式"><a href="#去中心化模式" class="header-anchor">#</a> 去中心化模式</h4> <p>这个架构会变的简单，复杂度到了事件处理者这里，不利于事件流程的增加，对于小规模的数据来说实现容易</p> <p>在这个架构下的执行逻辑：事件生产者-&gt;队列-&gt;事件处理者-&gt;……-&gt;其他事件处理者</p> <h3 id="微内核架构"><a href="#微内核架构" class="header-anchor">#</a> 微内核架构</h3> <p>在整个流程中，对于一个模块，有时候只想修改这个模块的一小部分的功能，同时希望热更新，不想影响正在进行的使用这个模块而没有使用这个功能的业务</p> <p>微内核架构中将这个模块的核心部分作为核心系统，其他部分作为插件可随意替换。</p> <p>核心系统提供微内核+内置插件+插件模块。微内核负责插件的生命周期管理和控制插件模块，插件模块负责插件的加载、替换和卸载。</p> <p>适用于：</p> <ul><li>业务逻辑不同，但共同的核心运行逻辑通用明确</li> <li>具有明确的增量开发预期</li> <li>功能的替换上线卸载方便，适用于模块功能可能变动频繁，或希望对模块功能有高度自定义能力</li></ul> <blockquote><p>这两个架构并没有清晰的界限，只是从不同的功能角度进行的划分，很多时候都是同时存在的。nginx就是一个典型的例子，请求到来通过事件框架接收移入对应队列，
http框架取队列调用不同模块执行11个阶段，这是典型的事件驱动架构。同时事件框架、http框架、配置模块等又构成微内核部分的核心系统，插件模块可以随需求增改</p></blockquote> <h2 id="拆库"><a href="#拆库" class="header-anchor">#</a> 拆库</h2> <p>随着用户增长，当瓶颈来到数据库时，硬盘盒内存的扩容相对容易，cpu飙高只能做拆分，将一个数据库的cpu压力分摊到多个 cpu上</p> <h3 id="拆库之前"><a href="#拆库之前" class="header-anchor">#</a> 拆库之前</h3> <p>在编程查询时，尽量将一些关联的查询操作体现在应用层，对多个表的联合查询拆分成一阶段并发查表得到数据，二阶段对数据计算得到结果</p> <p>首先确认问题，如果只是单表数据过大，导致SQL操作执行的比较慢，可以先拆表拆库</p> <p>其次可以先使用读写分离之类的方案来应对面临的问题</p> <h3 id="垂直拆分"><a href="#垂直拆分" class="header-anchor">#</a> 垂直拆分</h3> <p>水平拆分有更高的成本，业务对数据库的访问通常有大量的join、transaction需求：</p> <ul><li>要么舍弃不重要的捆绑逻辑，业务做出调整</li> <li>要么将联合查询相关的逻辑上浮，在业务层体现，会有一定的性能开销，查询更慢</li></ul> <p>通常优先考虑垂直拆分，以业务为维度，将不同无关业务的数据库拆分</p> <h3 id="水平拆分"><a href="#水平拆分" class="header-anchor">#</a> 水平拆分</h3> <p>通常写请求也涉及了读请求，所以优先找到读请求最高频的字段拆分，根据实际使用时代特点进行拆分</p> <p>几个拆分方案：</p> <ul><li>范围切分：一种连续式的切分方式</li></ul> <p>比如按照订单的创建时间划定范围进行切分，地域切分，</p> <ul><li>hash切分</li></ul> <p>将数据映射到不同节点。</p> <p>缺点：</p> <ol><li>如果有再次扩容一定有数据迁移。结合一致性哈希，创造多个虚拟节点，映射到不同的物理节点上，一定程度上能缓解数据迁移的压力</li> <li>同一用户的多条数据映射到不同节点了，同一用户的多条数据查询是概率事件。
通过在生成的唯一haship后追加一个useid，使得同一个用户的数据取模固定，从而固定存放到一个节点。
这个只能解决一部分问题，如果还有其他的关联操作，不能再用这个方法了</li></ol> <ul><li>全局表</li></ul> <p>维护一张全局表记录每个数据id和对应物理库/表的关系，每次查询时都经过全局表</p> <p>实现逻辑简单，但全局表有访问压力，且增加了请求链路长度。如果数据越大，越应考虑hash切分</p> <h1 id="高并发-缓存"><a href="#高并发-缓存" class="header-anchor">#</a> 高并发-缓存</h1> <h2 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="header-anchor">#</a> 常见的缓存更新策略</h2> <h3 id="cache-aside-旁路缓存-策略"><a href="#cache-aside-旁路缓存-策略" class="header-anchor">#</a> Cache Aside（旁路缓存）策略</h3> <p>实际中redis和mysql都使用这个策略</p> <p><strong>对于读</strong></p> <p>命中缓存则返回，没命中则从数据库读数据再写入缓存</p> <p><strong>对于写</strong></p> <p>先更新数据库的数据，再删除缓存的数据</p> <p>不能反过来，先删缓存再更新数据库会读写并发时出现缓存和数据库不一致</p> <ul><li>B读取数据a，缓存没命中，请求查询数据库</li> <li>A想更新数据a，删除缓存</li> <li>B得到a的旧值加入缓存</li> <li>A更新数据库的数据为新值，</li> <li>此时缓存的数据和数据库的数据不一致，将一直保持下去直到缓存失效</li></ul> <p>而先更新数据库再删除也会出现，但概率不高</p> <ul><li>B读取数据a，缓存没命中，请求查询数据库，得到旧值为20</li> <li>A想更新数据a，更新数据库为21</li> <li>A更新完数据库，删除缓存</li> <li>B将旧值写入缓存</li></ul> <p>对于步骤3和4，通常更新数据库比缓存的写入要慢，所以通常步骤4会先于步骤3发生</p> <p>如果要彻底解决这个问题：</p> <ol><li>更新值前加分布式锁，同一时间只允许一个线程更新，这会带来写入性能问题</li> <li>给缓存上租约，即使出现缓存不一致，也会很快过期，对业务的影响可接收</li></ol> <p>先写换缓存后DB只适用于对数据写性能要求很高，但数据准确性要求没那么高</p> <p><strong>单库写缓存失败</strong></p> <p>通常先写DB，在写缓存，如果写缓存失败了，回滚DB，但是回滚DB有可能失败（数据库压力过大），因此将回滚DB换成delete缓存，从而多一次的cache miss来换rollback DB失败的问题</p> <blockquote><p>？？：
对于redis这类数据库，写缓存失败很有可能是网络导致的，如果写缓存失败也意味着删除缓存也有可能失败
但是因为删除缓存是幂等操作，可以通过一些方式来保障删除缓存的操作，比如多次重试，延迟双删，异步队列，分布式事务等。即使删除操作延迟到达，删除了新的缓冲，下次读cache miss直接访问库也不会影响数据的一致。用这些方案依然有可能出现一段时间的数据不一致。
这些操作都比直接回滚DB更安全，回滚DB意味着数据库要执行一套写入流程，有更大的开销</p></blockquote> <p><strong>多库写缓存失败</strong></p> <p>问题：数据库在主从模式下，当数据未同步到从库时，由于cache miss去从库读数据读到旧值</p> <p>解决：</p> <ul><li><p>缓存定期访问数据库同步数据。消耗资源，存在一定时间的数据不一致。只适用于少量场景</p></li> <li><p>当从库同步主库数据后，再对缓存做一次delete或set。依然是最终一致性方案，但开销小</p></li> <li><p>有数据写入的这段时间强制读主库来加载缓存。每次写操作都伴随一个写共享存储数据的操作（带有租约），每次读时判断共享存储里这个值是否存在从而判断是否走主库。
对主库压力增大，适用于对数据一致性容忍度较高的场景</p></li></ul> <p>该策略适合读多写少，不适合写多的场景，写入频繁会使得缓存的数据频繁改变，从而缓存命中率低</p> <h3 id="read-write-through-读穿-写穿-策略"><a href="#read-write-through-读穿-写穿-策略" class="header-anchor">#</a> Read/Write Through(读穿/写穿)策略</h3> <p>应用程序只和缓存交互，缓存和数据库交互</p> <p><strong>对于读</strong></p> <p>查询缓存数据是否存在，存在则返回，不存在则由缓存组件从数据库查询，并写入缓存组件，缓存组件将数据返回给应用</p> <p><strong>对于写</strong></p> <p>先查询数据在缓存中是否存在，如果存在则更新缓存数据并同步更新数据库，然后缓存组件返回更新完成
如果不存在，更新数据库后返回</p> <p>开发中使用较少，因为常用的分布式缓存组件，例如memcached和redis都不提供和数据库交互的功能，对于我们自己写本地缓存可以使用这种策略</p> <h3 id="write-back-写回-策略"><a href="#write-back-写回-策略" class="header-anchor">#</a> Write Back（写回）策略</h3> <p>更新数据时只更新缓存，将缓存数据设置为脏并返回，不会更新数据库。对于数据库的更新会通过批量异步的方式进行</p> <p>这种方式常用于计算机体系结构中的设计，如CPU的缓存、os中文件系统的缓存</p> <p>适用写多的场景，但数据不是强一致性的，并且如果断电有数据丢失的风险</p> <h2 id="本地缓存和分布式缓存"><a href="#本地缓存和分布式缓存" class="header-anchor">#</a> 本地缓存和分布式缓存</h2> <blockquote><p>如果本地缓存只是做分布式缓存的缓存，用户请求只读本地缓存，本地缓存没有则从分布式缓存中引入，同时每个数据都有租约。那么没有下面说到这些问题
这里提到的本地缓存指本地存放分布式缓存里没有的业务数据</p></blockquote> <p>引入分布式缓存，能应对业务的增长，要求我们的程序是无状态的，而引入了本地缓存，变成了有状态，分布式缓存的作用就变小了</p> <p>本地缓存的使用场景：</p> <ul><li>不经常变动数据</li> <li>需要支持高并发（秒杀场景）</li> <li>对数据准确性能容忍</li></ul> <p><strong>本地缓存、分布式缓存、DB之间的数据一致性</strong></p> <p>多个本地缓存节点间的数据同步：</p> <ol><li>同步多个本地缓存，修改的节点通知其他节点变更。只适用于节点少的情况</li> <li>不同步多个本地缓存，借助一致性hash让请求落到一个节点。可能出现负载不均衡</li></ol> <h2 id="缓存带来的一些问题"><a href="#缓存带来的一些问题" class="header-anchor">#</a> 缓存带来的一些问题</h2> <h3 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> 缓存雪崩</h3> <p>当大量缓存在同一时间过期时，面对大量的用户请求，需要大量直接访问数据库，从而增大数据库压力，进一步会造成数据库宕机</p> <p>解决：</p> <ul><li>随机打散缓存失效时间：在原有的失效时间上增加一个随机值</li> <li>设置缓存不过期：通过后台服务来更新缓存数据</li></ul> <h3 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h3> <p>缓存击穿可以是缓存雪崩的子集</p> <p>有时有几个数据会被频繁访问，例如秒杀活动，这类数据被称为<strong>热点数据</strong></p> <p>如果热点数据过期了，大量的请求访问了该热点数据，无法在缓存中命中，直接访问数据库从而使得数据库很容易被冲垮</p> <p>解决：</p> <ul><li>互斥锁保证同一时间只有一个业务线程请求数据库</li> <li>不给热点数据设置过期时间，由后台异步更新缓存，在热点数据要过期前，通知后台线程更新缓存即重新设置过期时间</li></ul> <h3 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> 缓存穿透</h3> <p>用户访问的数据既不在缓存，也不在数据库中，此时无法构建缓存数据，当大量的这样的请求到来，造成数据库压力增大</p> <p><strong>通常原因</strong>：</p> <p>黑客恶意攻击，故意大量访问读取不存在的数据</p> <p>业务误操作，将数据库中的数据误删除了</p> <p><strong>解决</strong></p> <ol><li>非法请求的限制：判断请求参数是否合理</li> <li>设置空值或者默认值：对查询的数据设置空值或默认值，后续查询从缓存中取到空值</li> <li>l使用布隆过滤器快速判断数据是否存在，避免查询数据库：</li></ol> <h1 id="高并发-异步和同步"><a href="#高并发-异步和同步" class="header-anchor">#</a> 高并发-异步和同步</h1> <p>异步会产生线程的开销，因此只适用于网络/磁盘IO处理的地方</p> <p>需要注意：</p> <ul><li>客户端发起请求的线程和收到请求响应的线程可能不是一个，因此上下文不一定连续</li> <li>客户端的请求发起顺序和客户端收到的服务器回应顺序不一定一致</li></ul> <p>通常可以用请求/响应模型，异步通信中更适合抽象成事件来协作：</p> <p>客户端发布一个事件，不需要关心谁如何处理他，只需要知道结果。服务端可以在不影响客户端的情况下添加事件的订阅者</p> <p>通常请求/响应模型和事件是协作完成的：</p> <p>对于无需关心返回结果的操作可以通过事件的形式进行异步。当主体操作执行完成即返回给客户端，同时发布一个事件到消息队列或者写入DB，其他程序定期去完成执行这个事件</p> <p>带来的好处是：请求/响应模型下做异步，整个操作是否执行完成由最晚回调的时间决定，有可能去短板，缩短了整个操作的时间。避免了不重要事件的波动影响整个操作（例如记录日志）</p> <p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F/./image7.png" alt=""></p> <ul><li>**同步+阻塞：**请求并等待结果</li> <li><strong>同步+非阻塞</strong>：请求并周期性询问结果</li> <li><strong>异步+非阻塞</strong>：请求后，通过回调触发异步获得结果</li></ul> <h1 id="构建易测试的系统"><a href="#构建易测试的系统" class="header-anchor">#</a> 构建易测试的系统</h1> <ol><li>分层</li></ol> <p>做到高内聚低耦合。越大型的系统进行分层会更有利于单元测试，只测试修改的一部分，不需要从头测起</p> <ol start="2"><li>无状态</li></ol> <p>便于机器扩容</p> <ol start="3"><li>配置化参数代替硬编码</li></ol> <p>对于一些不好确定是否正确，人为界定的参数可以通过放到配置中</p> <ul><li>容量类</li> <li>次数类</li> <li>开关类</li> <li>时间类</li></ul> <ol start="4"><li>依赖注入</li></ol> <p>当希望在生产环境进行故障演练时，不能对正常的业务数据产生影响，只能单独准备数据库和演练数据。
将载入数据源的地方设计成依赖注入，从而能切换到不同的数据源</p> <ol start="5"><li>打日志</li></ol> <p>为了能更好的观测系统，</p> <ul><li>梳理，按照重要程度/应对方式来分等级</li> <li>归类，按不同模块</li></ul> <ol start="6"><li>接口版本化，向前兼容</li></ol> <p>在程序往下游系统分发请求时，将自己的版本号在消息头中带给网关或服务治理框架，从而让其路由到指定的服务节点上去</p> <h1 id="监控"><a href="#监控" class="header-anchor">#</a> 监控</h1> <p>监控目标来看</p> <ol><li>环境指标：监控网络I/O、磁盘、内存、CPU等。成熟的产品有zabbix</li> <li>程序指标：除了和环境指标一样的，还有应用程序错误数，请求量，平均响应时间</li></ol> <p>程序的监控要考虑是否无入侵。如果有网关来统一进行流量分发，或rpc框架这样的统一模块，直接在这些模块里增加监控功能</p> <p>对于采集到底数据，写入到时序数据库中。</p> <p>如果没有统一框架，考虑通过AOP的方式来降低埋点代码的编写量</p> <ol start="3"><li>业务指标</li></ol></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/liang9886703/edit/master/docs/02.分布式/03.分布式架构.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2025/02/13, 23:35:20</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/02/02/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">分布式ID生成</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/02/02/" class="prev">分布式ID生成</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/02/01/"><div>
            一致性算法
            <!----></div></a> <span class="date">02-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/01/01/"><div>
            vim
            <!----></div></a> <span class="date">02-13</span></dt></dl><dl><dd>03</dd> <dt><a href="/02/02/"><div>
            分布式ID生成
            <!----></div></a> <span class="date">02-13</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:liang9886703@outlook.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/liang9886703" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2025-2025
    <span>松垮垮 | <a href="https://github.com/liang9886703/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a> | <a href="http://beian.miit.gov.cn/" target="_blank">蜀ICP备2025120453号</a> | <img src="/img/beian.png" style="width: 15px; margin-bottom: -3px;" /> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=51011202000997" rel="noreferrer" target="_blank">川公网安备51011202000997号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          纯净模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center  top / 90% 90% no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.41210a84.js" defer></script><script src="/assets/js/2.ddcc22d9.js" defer></script><script src="/assets/js/3.9a514af0.js" defer></script><script src="/assets/js/18.693f6f3c.js" defer></script>
  </body>
</html>
