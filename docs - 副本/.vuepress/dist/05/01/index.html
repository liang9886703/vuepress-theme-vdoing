<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis原理 | 松垮垮</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="后端开发等技术文章。">
    <meta name="keywords" content="后端博客,个人技术博客,后端,后端开发,后端框架,后端面试题,技术文档,学习,面试,c++,git,github">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.4229948e.css" as="style"><link rel="preload" href="/assets/js/app.41210a84.js" as="script"><link rel="preload" href="/assets/js/2.ddcc22d9.js" as="script"><link rel="preload" href="/assets/js/3.9a514af0.js" as="script"><link rel="preload" href="/assets/js/30.0fbcfcdc.js" as="script"><link rel="prefetch" href="/assets/js/10.c5ea2586.js"><link rel="prefetch" href="/assets/js/11.345c12e4.js"><link rel="prefetch" href="/assets/js/12.7bd611a3.js"><link rel="prefetch" href="/assets/js/13.e31f4e59.js"><link rel="prefetch" href="/assets/js/14.6cd7ac12.js"><link rel="prefetch" href="/assets/js/15.9d43ec16.js"><link rel="prefetch" href="/assets/js/16.96ef5845.js"><link rel="prefetch" href="/assets/js/17.930177fa.js"><link rel="prefetch" href="/assets/js/18.693f6f3c.js"><link rel="prefetch" href="/assets/js/19.e757fc80.js"><link rel="prefetch" href="/assets/js/20.ed5c437a.js"><link rel="prefetch" href="/assets/js/21.c41265c1.js"><link rel="prefetch" href="/assets/js/22.ed241c46.js"><link rel="prefetch" href="/assets/js/23.7a084215.js"><link rel="prefetch" href="/assets/js/24.2e695667.js"><link rel="prefetch" href="/assets/js/25.3a8e1528.js"><link rel="prefetch" href="/assets/js/26.a630eff6.js"><link rel="prefetch" href="/assets/js/27.a26a85aa.js"><link rel="prefetch" href="/assets/js/28.532ed3b7.js"><link rel="prefetch" href="/assets/js/29.fa09431b.js"><link rel="prefetch" href="/assets/js/31.b7ca18e2.js"><link rel="prefetch" href="/assets/js/32.51e3797a.js"><link rel="prefetch" href="/assets/js/33.c79407e6.js"><link rel="prefetch" href="/assets/js/34.c1709f1a.js"><link rel="prefetch" href="/assets/js/35.a1680b5b.js"><link rel="prefetch" href="/assets/js/36.4692c6d1.js"><link rel="prefetch" href="/assets/js/37.1caefdec.js"><link rel="prefetch" href="/assets/js/38.158e350f.js"><link rel="prefetch" href="/assets/js/39.a64bf6b9.js"><link rel="prefetch" href="/assets/js/4.ce7d70a4.js"><link rel="prefetch" href="/assets/js/40.def4302a.js"><link rel="prefetch" href="/assets/js/41.d8026554.js"><link rel="prefetch" href="/assets/js/42.496b6914.js"><link rel="prefetch" href="/assets/js/43.67cc445d.js"><link rel="prefetch" href="/assets/js/44.3f5aa743.js"><link rel="prefetch" href="/assets/js/45.ea91ad4f.js"><link rel="prefetch" href="/assets/js/46.80d186c9.js"><link rel="prefetch" href="/assets/js/47.ecf0e135.js"><link rel="prefetch" href="/assets/js/48.001b8a90.js"><link rel="prefetch" href="/assets/js/49.7d13e977.js"><link rel="prefetch" href="/assets/js/5.a0af7f8a.js"><link rel="prefetch" href="/assets/js/50.c78d144d.js"><link rel="prefetch" href="/assets/js/51.d0c87914.js"><link rel="prefetch" href="/assets/js/52.11fa1467.js"><link rel="prefetch" href="/assets/js/53.f05510d9.js"><link rel="prefetch" href="/assets/js/54.5800936b.js"><link rel="prefetch" href="/assets/js/55.ffc15fea.js"><link rel="prefetch" href="/assets/js/56.88e0791b.js"><link rel="prefetch" href="/assets/js/57.86abaef0.js"><link rel="prefetch" href="/assets/js/58.ccb34ddc.js"><link rel="prefetch" href="/assets/js/59.39016f6c.js"><link rel="prefetch" href="/assets/js/6.2205d704.js"><link rel="prefetch" href="/assets/js/7.6ae52fc4.js"><link rel="prefetch" href="/assets/js/8.8a6895b8.js"><link rel="prefetch" href="/assets/js/9.10468b6d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4229948e.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="松垮垮" class="logo"> <span class="site-name can-hide">松垮垮</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="quicker" class="dropdown-title"><a href="/01/" class="link-title">quicker</a> <span class="title" style="display:none;">quicker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01/01/" class="nav-link">vim.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><a href="/02/" class="link-title">分布式</a> <span class="title" style="display:none;">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02/01/" class="nav-link">一致性算法.md</a></li><li class="dropdown-item"><!----> <a href="/02/02/" class="nav-link">分布式ID生成.md</a></li><li class="dropdown-item"><!----> <a href="/02/03/" class="nav-link">分布式架构.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/03/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03/01/" class="nav-link">css.md</a></li><li class="dropdown-item"><!----> <a href="/03/02/" class="nav-link">html.md</a></li><li class="dropdown-item"><!----> <a href="/03/03/" class="nav-link">JavaScript.md</a></li><li class="dropdown-item"><!----> <a href="/03/04/" class="nav-link">vue.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统" class="dropdown-title"><a href="/04/" class="link-title">操作系统</a> <span class="title" style="display:none;">操作系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/04/01/" class="nav-link">内存管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/02/" class="nav-link">文件系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/03/" class="nav-link">硬件结构.md</a></li><li class="dropdown-item"><!----> <a href="/04/04/" class="nav-link">网络系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/05/" class="nav-link">设备管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/06/" class="nav-link">调试技术.md</a></li><li class="dropdown-item"><!----> <a href="/04/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/05/" class="link-title router-link-active">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/05/01/" aria-current="page" class="nav-link router-link-exact-active router-link-active">redis原理.md</a></li><li class="dropdown-item"><!----> <a href="/05/02/" class="nav-link">数据库.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="服务器开发" class="dropdown-title"><a href="/06/" class="link-title">服务器开发</a> <span class="title" style="display:none;">服务器开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06/01/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/06/02/" class="nav-link">nginx环境+编译+调试.md</a></li><li class="dropdown-item"><!----> <a href="/06/03/" class="nav-link">高性能linux服务器.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络编程" class="dropdown-title"><a href="/07/" class="link-title">网络编程</a> <span class="title" style="display:none;">网络编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/07/01/01/" class="nav-link">IP</a></li><li class="dropdown-item"><!----> <a href="/07/02/" class="nav-link">网络工具.md</a></li><li class="dropdown-item"><!----> <a href="/07/03/" class="nav-link">网络编程.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/08/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/08/01/" class="nav-link">GPU并行编程.md</a></li><li class="dropdown-item"><!----> <a href="/08/02/" class="nav-link">mysql.md</a></li><li class="dropdown-item"><!----> <a href="/08/03/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/08/04/" class="nav-link">redis.md</a></li><li class="dropdown-item"><!----> <a href="/08/05/" class="nav-link">网络.md</a></li><li class="dropdown-item"><!----> <a href="/08/06/" class="nav-link">计算机视觉.md</a></li><li class="dropdown-item"><!----> <a href="/08/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目bug" class="dropdown-title"><a href="/09/" class="link-title">项目bug</a> <span class="title" style="display:none;">项目bug</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09/01/" class="nav-link">linux调试.md</a></li><li class="dropdown-item"><!----> <a href="/09/02/" class="nav-link">【Python】：re.error bad escape i at position 4.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/liang9886703" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103123203.jpg"> <div class="blogger-info"><h3>松垮垮</h3> <span>c++后端开发工程师</span> <span></span> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="quicker" class="dropdown-title"><a href="/01/" class="link-title">quicker</a> <span class="title" style="display:none;">quicker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01/01/" class="nav-link">vim.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><a href="/02/" class="link-title">分布式</a> <span class="title" style="display:none;">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02/01/" class="nav-link">一致性算法.md</a></li><li class="dropdown-item"><!----> <a href="/02/02/" class="nav-link">分布式ID生成.md</a></li><li class="dropdown-item"><!----> <a href="/02/03/" class="nav-link">分布式架构.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/03/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03/01/" class="nav-link">css.md</a></li><li class="dropdown-item"><!----> <a href="/03/02/" class="nav-link">html.md</a></li><li class="dropdown-item"><!----> <a href="/03/03/" class="nav-link">JavaScript.md</a></li><li class="dropdown-item"><!----> <a href="/03/04/" class="nav-link">vue.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统" class="dropdown-title"><a href="/04/" class="link-title">操作系统</a> <span class="title" style="display:none;">操作系统</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/04/01/" class="nav-link">内存管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/02/" class="nav-link">文件系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/03/" class="nav-link">硬件结构.md</a></li><li class="dropdown-item"><!----> <a href="/04/04/" class="nav-link">网络系统.md</a></li><li class="dropdown-item"><!----> <a href="/04/05/" class="nav-link">设备管理.md</a></li><li class="dropdown-item"><!----> <a href="/04/06/" class="nav-link">调试技术.md</a></li><li class="dropdown-item"><!----> <a href="/04/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/05/" class="link-title router-link-active">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/05/01/" aria-current="page" class="nav-link router-link-exact-active router-link-active">redis原理.md</a></li><li class="dropdown-item"><!----> <a href="/05/02/" class="nav-link">数据库.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="服务器开发" class="dropdown-title"><a href="/06/" class="link-title">服务器开发</a> <span class="title" style="display:none;">服务器开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06/01/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/06/02/" class="nav-link">nginx环境+编译+调试.md</a></li><li class="dropdown-item"><!----> <a href="/06/03/" class="nav-link">高性能linux服务器.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络编程" class="dropdown-title"><a href="/07/" class="link-title">网络编程</a> <span class="title" style="display:none;">网络编程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/07/01/01/" class="nav-link">IP</a></li><li class="dropdown-item"><!----> <a href="/07/02/" class="nav-link">网络工具.md</a></li><li class="dropdown-item"><!----> <a href="/07/03/" class="nav-link">网络编程.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/08/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/08/01/" class="nav-link">GPU并行编程.md</a></li><li class="dropdown-item"><!----> <a href="/08/02/" class="nav-link">mysql.md</a></li><li class="dropdown-item"><!----> <a href="/08/03/" class="nav-link">nginx.md</a></li><li class="dropdown-item"><!----> <a href="/08/04/" class="nav-link">redis.md</a></li><li class="dropdown-item"><!----> <a href="/08/05/" class="nav-link">网络.md</a></li><li class="dropdown-item"><!----> <a href="/08/06/" class="nav-link">计算机视觉.md</a></li><li class="dropdown-item"><!----> <a href="/08/07/" class="nav-link">进程管理.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目bug" class="dropdown-title"><a href="/09/" class="link-title">项目bug</a> <span class="title" style="display:none;">项目bug</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09/01/" class="nav-link">linux调试.md</a></li><li class="dropdown-item"><!----> <a href="/09/02/" class="nav-link">【Python】：re.error bad escape i at position 4.md</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/liang9886703" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/05/01/" aria-current="page" class="active sidebar-link">redis原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/05/01/#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#哈希表结构" class="sidebar-link">哈希表结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#rehash" class="sidebar-link">rehash</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#int类型的编码方式" class="sidebar-link">int类型的编码方式</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#sds-simple-dynamic-string" class="sidebar-link">SDS（simple dynamic string)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#sds结构" class="sidebar-link">SDS结构</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#embstr类型的编码方式" class="sidebar-link">embstr类型的编码方式</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#raw类型的编码方式" class="sidebar-link">raw类型的编码方式</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#raw相比embstr" class="sidebar-link">raw相比embstr</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#sds优点" class="sidebar-link">SDS优点</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#扩容策略" class="sidebar-link">扩容策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#压缩列表ziplist" class="sidebar-link">压缩列表ziplist</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#优缺" class="sidebar-link">优缺</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#结构设计" class="sidebar-link">结构设计</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#连锁更新" class="sidebar-link">连锁更新</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#listpack" class="sidebar-link">listpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#结构" class="sidebar-link">结构</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#string类型" class="sidebar-link">string类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#命令" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#list类型" class="sidebar-link">list类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#底层实现" class="sidebar-link">底层实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#命令-2" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-2" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#hash类型" class="sidebar-link">hash类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#底层实现-2" class="sidebar-link">底层实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#命令-3" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-3" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#set类型" class="sidebar-link">set类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#底层实现-3" class="sidebar-link">底层实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#命令-4" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-4" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#zset类型" class="sidebar-link">ZSet类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#底层实现-4" class="sidebar-link">底层实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#命令-5" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-5" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#bitmap" class="sidebar-link">BitMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#内部实现" class="sidebar-link">内部实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#命令-6" class="sidebar-link">命令</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-6" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#hyperloglog" class="sidebar-link">HyperLogLog</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#使用" class="sidebar-link">使用</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-7" class="sidebar-link">应用场景</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#geo" class="sidebar-link">GEO</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#内部实现-2" class="sidebar-link">内部实现</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-8" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#stream" class="sidebar-link">stream</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#命令使用" class="sidebar-link">命令使用</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#应用场景-消息队列" class="sidebar-link">应用场景-消息队列</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#redis单线程模式" class="sidebar-link">redis单线程模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#事件循环函数" class="sidebar-link">事件循环函数</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#redis为什么使用单线程" class="sidebar-link">redis为什么使用单线程</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#为什么引入了多线程" class="sidebar-link">为什么引入了多线程</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#主要实现方式" class="sidebar-link">主要实现方式</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#aof日志" class="sidebar-link">AOF日志</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#aof日志格式" class="sidebar-link">AOF日志格式</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#aof写回策略" class="sidebar-link">AOF写回策略</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#aof重写机制" class="sidebar-link">AOF重写机制</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#rdb快照" class="sidebar-link">RDB快照</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#快照的线程阻塞机制" class="sidebar-link">快照的线程阻塞机制</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#混合持久化" class="sidebar-link">混合持久化</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#主从复制" class="sidebar-link">主从复制</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#哨兵模式" class="sidebar-link">哨兵模式</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#切片集群模式" class="sidebar-link">切片集群模式</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#惰性删除策略" class="sidebar-link">惰性删除策略</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#定期删除策略" class="sidebar-link">定期删除策略</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#持久化时-对于过期键如何处理" class="sidebar-link">持久化时，对于过期键如何处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#rdb文件" class="sidebar-link">RDB文件</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#aof文件" class="sidebar-link">AOF文件</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#主从模式中-对过期键的处理" class="sidebar-link">主从模式中，对过期键的处理</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#内存淘汰机制" class="sidebar-link">内存淘汰机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#删除策略" class="sidebar-link">删除策略</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#lru算法-redis4-0前使用" class="sidebar-link">LRU算法(redis4.0前使用)</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#lfu算法-redis4-0后默认-最近最不常用" class="sidebar-link">LFU算法（redis4.0后默认）最近最不常用</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#缓存雪崩" class="sidebar-link">缓存雪崩</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#缓存击穿" class="sidebar-link">缓存击穿</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#缓存穿透" class="sidebar-link">缓存穿透</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#如何设计动态缓存热点数据" class="sidebar-link">如何设计动态缓存热点数据</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#常见的缓存更新策略" class="sidebar-link">常见的缓存更新策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/05/01/#cache-aside-旁路缓存-策略" class="sidebar-link">Cache Aside（旁路缓存）策略</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#read-write-through-读穿-写穿-策略" class="sidebar-link">Read/Write Through(读穿/写穿)策略</a></li><li class="sidebar-sub-header level3"><a href="/05/01/#write-back-写回-策略" class="sidebar-link">Write Back（写回）策略</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/05/01/#如何实现延迟队列" class="sidebar-link">如何实现延迟队列</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#对于大key如何处理" class="sidebar-link">对于大key如何处理</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#redis管道的作用" class="sidebar-link">redis管道的作用</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#redis事务支持回滚吗" class="sidebar-link">redis事务支持回滚吗</a></li><li class="sidebar-sub-header level2"><a href="/05/01/#redis实现分布式锁" class="sidebar-link">redis实现分布式锁</a></li></ul></li><li><a href="/05/02/" class="sidebar-link">数据库</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/05/#数据库" data-v-06970110>数据库</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/liang9886703" target="_blank" title="作者" class="beLink" data-v-06970110>songkuakua</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2025-02-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">redis原理<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="redis概述"><a href="#redis概述" class="header-anchor">#</a> redis概述</h1> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>是一种内存数据结构存储，用作数据库、缓存、消息代理、流引擎</p> <p>redis作为msql的缓存，因为其有高性能和高并发</p> <p><strong>特点</strong></p> <ul><li>定期将数据转到磁盘持久化，也可以关闭这个功能</li> <li>支持多种数据结构并对其运行原子操作：</li> <li>基于内存的数据库，读写操作在内存中完成，读写速度很快</li> <li>支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等</li></ul> <p><strong>redis和etcd</strong></p> <p>redis有更好的查询性能，支持更多的数据结果
etcd更为可靠安全，故障转移和持续数据可用，数据均持久化</p> <p><strong>redis和memcached</strong></p> <p>共同点：
两者都是基于内存的数据库，作为缓存使用，有极高的性能
都有过期策略</p> <p>区别：</p> <ul><li>redis支持更多数据类型，memcached是kv数据类型</li> <li>redis有持久化功能，memcached没有</li> <li>redis支持集群模式，memcached没有原生的集群模式</li> <li>redis支持发布订阅模型、lua脚本、事务等功能，memcached不支持</li></ul> <h1 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h1> <p>redis的所有对象都用redisObject保存</p> <p><strong>redis整体上是一个键值对数据库</strong>，非关系型数据库</p> <p>key为字符串对象，value可以是string、list、hash、set、zset</p> <p>对于这些键值对，redis统一使用哈希表来保存所有键值对，一个哈希桶存放的是指向键值对数据的指针，通过指针找到键值对数据，键值对数据再保存指向实际数据对的指针</p> <h2 id="哈希表结构"><a href="#哈希表结构" class="header-anchor">#</a> 哈希表结构</h2> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231124101640025.png" alt="image-20231124101640025"></p> <p>hash数据类型用的是哈希表+listpack实现</p> <p>哈希表底层用的拉链法解决冲突</p> <p>拉链法解决冲突时，长期使用导致一个冲突的哈希桶有太多值，冲突概率增大，因此需要rehash来定期维护哈希表</p> <h3 id="rehash"><a href="#rehash" class="header-anchor">#</a> rehash</h3> <p>字符串对象的内部编码有三种：int、raw、embstr</p> <h2 id="int类型的编码方式"><a href="#int类型的编码方式" class="header-anchor">#</a> int类型的编码方式</h2> <ul><li>保存对象是整数值</li> <li>可以被long类型标识</li></ul> <p>那么会将整数值保存在字符串对象结构的ptr属性里，编码设置为int</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231104164254447.png" alt="image-20231104164254447"></p> <h2 id="sds-simple-dynamic-string"><a href="#sds-simple-dynamic-string" class="header-anchor">#</a> SDS（simple dynamic string)</h2> <p>来表示string字符串数据类型</p> <p><strong>c语言字符串的缺陷</strong></p> <ul><li>获取字符串长度的时间复杂度为O(N)</li> <li>字符串不能含有“\0”,即只能放文本数据，不能保存二级制数据</li> <li>c语言标准库中字符串的操作函数是不安全、不高效</li></ul> <h3 id="sds结构"><a href="#sds结构" class="header-anchor">#</a> SDS结构</h3> <p>sds分成多种，sdshdr5、sdshdr8、sdshdr16、sdshdr32、dsdhdr64用于存储不同长度的字符串，即len和alloc成员变量的数据类型不同，sdshdr几，代表uint为多少位。sdshdr16，则len和alloc为uint16_t类型。</p> <p><code>__arrtibute__</code> 表示取消结构体在编译过程中的优化对齐，按照实际占用字节数对齐</p> <p>采用SDS结构的编码方式有两种embstr和raw</p> <h3 id="embstr类型的编码方式"><a href="#embstr类型的编码方式" class="header-anchor">#</a> embstr类型的编码方式</h3> <p>专用于保存短字符串</p> <ul><li>保存的是一个字符串</li> <li>字符串长度&lt;=44字节（redis5.0）</li></ul> <p>将使用简单动态字符串SDS来保存这个字符串，并将对象的编码设置为embstr</p> <p>字符串对象结构里保存SDS的数据信息，用buf指针指向实值</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231104164756548.png" alt="image-20231104164756548"></p> <p>redisObject结构</p> <p>SDS结构sdshdr</p> <p>redisObject(16) + SDS(47) + 结束符\0（1）=64</p> <p>sdshdr会分配8，16，32，64字节的内存</p> <h3 id="raw类型的编码方式"><a href="#raw类型的编码方式" class="header-anchor">#</a> raw类型的编码方式</h3> <ul><li>保存的是字符串</li> <li>字符串长度&gt;44字节（redis5.0)</li></ul> <p>用SDS来保存这个字符串，并将对象的编码设置为raw</p> <p>ptr指向SDS的数据信息，用buf指针指向实值</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231104165041851.png" alt="image-20231104165041851"></p> <h3 id="raw相比embstr"><a href="#raw相比embstr" class="header-anchor">#</a> raw相比embstr</h3> <p>embstr一次分配一块连续的内存空间来保存redisObject和SDS</p> <p>raw编码通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS</p> <p>embstr优点</p> <ul><li>embstr有更少的内存分配和释放次数</li> <li>连续的内存空间有更好的查询效率</li></ul> <p>embstr缺点</p> <ul><li>字符串长度增加时，redisObject和sds都需要重新分配空间</li></ul> <blockquote><p>因此embstr编码的字符串对象实际上是只读的，没有修改它的程序，如果要修改，会将其转为raw再修改</p></blockquote> <h3 id="sds优点"><a href="#sds优点" class="header-anchor">#</a> <strong>SDS优点</strong></h3> <p>redis的SDS结构在原本字符数组上，增加了三个元数据来解决c语言字符串的缺陷。</p> <ol><li>二级制安全：SDS为了兼容c标准库函数，依然在结尾加上“\0”字符。同时程序不会对其中的数据做任何限制，数据写入和读取是一样的</li> <li>O（1)复杂度获取字符串长度</li> <li>不会发生缓冲区溢出：alloc和len可以计算出剩余空间的大小，自动扩容</li></ol> <h3 id="扩容策略"><a href="#扩容策略" class="header-anchor">#</a> <strong>扩容策略</strong></h3> <p>sds长度小于1MB，翻倍扩容</p> <p>sds长度超过1MB，依次增加1MB</p> <h2 id="压缩列表ziplist"><a href="#压缩列表ziplist" class="header-anchor">#</a> 压缩列表ziplist</h2> <h3 id="优缺"><a href="#优缺" class="header-anchor">#</a> 优缺</h3> <p>优点：</p> <ul><li>采用连续的内存空间，利用上了cpu缓存</li> <li>对不同长度的数据采用不同的编码，节省内存开销</li></ul> <p>缺点：</p> <ul><li>元素的增加会降低查询效率</li> <li>新增或修改元素时内存空间需要重新分配、</li> <li>新增或修改元素可能引发连锁更新</li></ul> <h3 id="结构设计"><a href="#结构设计" class="header-anchor">#</a> 结构设计</h3> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231124110938019.png" alt="image-20231124110938019"></p> <p>由如下五部分构成</p> <ul><li>zlbytes 记录整个压缩列表占用内存字节数</li> <li>zltail 记录到表尾的偏移量</li> <li>zllen 记录压缩列表包含的节点数量</li> <li>entry 实际的值</li> <li>zlend 列表的结束点，固定0xFF</li></ul> <p><strong>entry结构</strong></p> <ul><li>prevlen 记录前一个节点的长度，用于从后往前遍历，
<ul><li>如果前一个节点长度小于254，则用1字节来保存长度，</li> <li>如果大于等于254字节，用5字节来保存长度</li></ul></li> <li>encoding，记录当前节点实际数据的类型和长度 （字符串和整数）</li> <li>data 实际数据</li></ul> <p>encoding部分和listpack类似</p> <h3 id="连锁更新"><a href="#连锁更新" class="header-anchor">#</a> 连锁更新</h3> <p>新增元素或修改元素时，如果空间不够，压缩列表需要重新分配空间，想象一个压缩列表目前所有元素的长度都是253字节</p> <p>原本下个元素的上个元素小于254，下个元素用1字节保存长度，</p> <p>插入一个大元素时，下个元素用5个字节prevlen来保存长度，即下个元素的长度整体扩大了4个字节，超过了254，迫使下下个元素的prevlen字节也要扩容，这样连锁下去</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231124113010853.png" alt="image-20231124113010853"></p> <h2 id="listpack"><a href="#listpack" class="header-anchor">#</a> listpack</h2> <h3 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h3> <p>对于链表，采用跳表，因此用紧凑列表</p> <p>紧凑列表，用连续的内存空间保存数据，用不同的编码方式保存不同长度的数据，listpack将字符串列表进行序列化存储</p> <p>**listpack构成：**由四部分组成</p> <ul><li>total bytes：表示整个listpack的空间大小，占用4个字节</li> <li>num elem：表示元素个数，即entry的个数，占用2个字节，超过2个字节的元素个数也可以存放，只是要遍历整个listpack</li> <li>entry为具体的元素</li> <li>end为listpack结束标志，1字节，内容为0xFF</li></ul> <p><strong>entry结构</strong></p> <ul><li>编码类型encoding type</li> <li>数据data</li> <li>前两部分的长度element-tot-len（&lt;=5字节）,第一个bit用于标识，0标识结束，1表示未结束，每个字节只有7bit有效</li></ul> <p>其中data部分的数据如果很短可以放在type字段中</p> <p>通过element-tot-len可以计算出type和data的总长度从而找到上一个元素的首地址</p> <p><strong>type编码方式</strong></p> <p>对于小的数字：用1字节表示</p> <p><code>0|xxxxxxx</code></p> <p>对于小的字符串：6位字符串长度，后面是字符串内容</p> <p><code>10|xxxxxx &lt;string-data&gt;</code></p> <p>多字节编码：</p> <p>@避免连锁更新的实现方式</p> <p>每个列表只记录自己的长度，不会像ziplist中的列表项那样记录前一项的长度。当在修改或新增元素时，只会涉及每个列表项自己的操作，不影响后续列表项的长度变化，从而避免连锁更新</p> <p><strong>查询</strong></p> <p>正向查询：listpack保存了LP_HDR_SIZE，用于吧指针移到第一个entry列表项</p> <ol><li>listpack的结构记录了编码类型，从而得知encoding+data的总长度len1</li> <li>通过len1计算出element-tot-len的长度</li> <li>len1+element-tot-len之和为entry的总长度len</li> <li>向后移动总长度len即为下应该列表项的起始位置</li></ol> <p>反向查询：</p> <p>element-tot-len的第一位为1表示没有结束，左边字节仍然为element-tot-len的内容，第一位为0表示结束，element-tot-len的低7位采用大端模式存储</p> <p>element-tot-len记录了这个字节的长度，即上个字节的地址</p> <p><strong>删除</strong></p> <p>用空元素替换</p> <p><strong>改和插入</strong></p> <ol><li>计算插入后的整个listpack空间，通过realloc申请空间</li> <li>调整新listpakc中老元素的位置，加入新元素</li> <li>释放旧listpack</li> <li>更新新listpack信息</li></ol> <h1 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h1> <p><strong>支持的数据类型和应用场景</strong>：</p> <ul><li>String(字符串)：缓存对象、分布式锁、共享session信息</li> <li>Hash(哈希)：缓存对象、例如：购物车</li> <li>List (列表)：消息队列</li> <li>Set(集合)：聚合（交并差）计算，例如：共同关注</li> <li>Zset(有序集合)：排序场景</li> <li>Bitmaps（位图）：二值状态的统计，例如：签到、判断登录状态</li> <li>HyperLogLog（基数统计）：例如：网页UV计数（独立访客统计）</li> <li>GEO（地理信息）：储存地理位置信息的场景</li> <li>Stream（流）：消息队列</li></ul> <p>HyperLogLog比起set占用更小空间，仅实现基数统计，对于2^64个不同元素的基数只需用12KB的内存，结果的误差在一定范围内</p> <p>例如：数据集{1，3，5，7，5，7，8}的基数集为{1，3，5，7，8}，基数为5</p> <p>stream比起list，自动生成全局唯一消息ID，支持以消费组形式消费数据</p> <h2 id="string类型"><a href="#string类型" class="header-anchor">#</a> string类型</h2> <p>是kv结构，value最多容纳数据512M</p> <p>底层为SDS（简单动态字符串），相比起c字符串</p> <ul><li>SDS可以保存文本数据和二进制数据，使用len属性的值来判断字符串是否结束，包含图片、音视频、压缩文件等</li> <li>获取字符串长度的时间复杂度是O（1）</li> <li>SDS的API是安全的，拼接字符串会自动扩容</li></ul> <h3 id="命令"><a href="#命令" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <p>1、缓存对象</p> <p>使用string来缓存对象有两种方式：</p> <ul><li><p>直接缓存整个对象的JSON</p> <p>例：<code>SET user:1 {“name” : “xiaolin”, “age”:18’</code>}</p></li> <li><p>将key分离为属性，采用mset存储，由mget获取个属性值</p> <p>例：MEST user:1:name xiaolin user:1:age 18</p></li></ul> <p>2、常规计数</p> <p>redis是单线程的，命令的执行为原子的，适用访问次数、点赞等</p> <p>3、分布式锁</p> <p>利用当key不存在再插入这个特性可以用它来实现分布式锁</p> <p><code>set lock_key unique_value NX PX 10000</code></p> <ul><li>lock_key表示加锁名</li> <li>unique_value为客户端生成的唯一标识，用来确认谁加的锁</li> <li>NX表示不存在则插入，</li> <li>PX表示过期时间为10000</li></ul> <p>解锁的过程就是将lock_key键删除，注意删除前要先判断下value是当前客户端的唯一标识</p> <p>解锁过程涉及两个操作因此要用Lua脚本来保证原子性</p> <p>4、共享session信息</p> <p>在分布式系统下，用户一的session信息存储在服务器一，第二次访问时被分配到服务器二，这时服务器二没有用户一的session信息，因此需要redis对session信息统一存储管理</p> <p>将session信息存入redis服务器，多个服务器公用它</p> <img src="image-20231104175514571.png" alt="image-20231104175514571" style="zoom:33%;"> <h2 id="list类型"><a href="#list类型" class="header-anchor">#</a> list类型</h2> <p>可以两头写，无顺序，简单字符串列表，最大长度为2^32-1</p> <h3 id="底层实现"><a href="#底层实现" class="header-anchor">#</a> 底层实现</h3> <p>底层为双向链表或压缩列表</p> <ul><li>列表的元素&lt;512个（可配置），并且每个元素的值小于64字节，redis会使用压缩列表</li> <li>其他情况用双向链表</li></ul> <p>redis 3.2之后，全部由quicklist实现</p> <h3 id="命令-2"><a href="#命令-2" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h3> <p>1、消息队列</p> <p>list 和 stream均可实现</p> <p>存取消息必须满足：<strong>消息保序、处理重复的消息、保证消息可靠性</strong></p> <p><strong>@ 如何满足消息保序需求</strong></p> <p>队列先入先出本身能满足消息保序，LPUSH+RPOP(RPUSH+LPOP)</p> <p>为了生产者能通知消费者，redis提供BRPOP命令阻塞读取，没有读到队列数据时自动阻塞，有新的数据后再读取，比起轮询减少CPU开销</p> <p><strong>@ 如何处理重复的消息</strong></p> <p>消费者要实现重复的消息判断</p> <ul><li>每个消息有全局ID</li> <li>消息者要记录处理过的消息ID，重复的不处理</li></ul> <p>list并不会对每个消息生成ID号，需要程序员在list里包含这个ID</p> <p><strong>@ 如何保证消息可靠性</strong></p> <p>消费者从list取出消息，list不会保存这个消息，如果消费者故障，则消息没有处理就丢失了</p> <p>BRPOPLPUSH命令能让消费者程序从一个list中读消息，同时redis将这个消息插入另一个list备份</p> <p><strong>@ list存在的缺陷</strong></p> <p>不支持多个消费者读同一消息</p> <h2 id="hash类型"><a href="#hash类型" class="header-anchor">#</a> hash类型</h2> <p>hash是键值对的集合，value=[{field1， value1}，……{fieldN, valueN}]</p> <p>string是一个KV对，hash一个K能存放多个field，对应多个值</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231106092831686.png" alt="image-20231106092831686"></p> <h3 id="底层实现-2"><a href="#底层实现-2" class="header-anchor">#</a> 底层实现</h3> <p>底层为压缩列表或哈希表</p> <ul><li>列表的元素&lt;512个（可配置），并且每个元素的值小于64字节，redis会使用压缩列表</li> <li>其他情况用hash表</li></ul> <p>redis 7.0后压缩列表替换为<strong>listpack</strong>实现</p> <h3 id="命令-3"><a href="#命令-3" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h3> <p>1、缓存对象</p> <p>（对象id，属性，值）</p> <p>string+Json也可以存储对象，一般对象中频繁变化的属性可以抽出来用hash储存</p> <p>2、购物车</p> <p>key:(field、value) 对应    用户id：（商品id、数量）</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231106095748087.png" alt="image-20231106095748087"></p> <h2 id="set类型"><a href="#set类型" class="header-anchor">#</a> set类型</h2> <p>无序并唯一的键值集合，最多存储2^32-1个元素，可以支持取交集并集差集</p> <p><strong>set与list的区别：</strong></p> <ul><li>set只能存储非重复元素、list可以存储重复元素</li> <li>list是按照元素的先后顺序存储，set无序存储</li></ul> <h3 id="底层实现-3"><a href="#底层实现-3" class="header-anchor">#</a> 底层实现</h3> <p>底层为哈希表或整数集合</p> <ul><li>列表的元素&lt;512个（可配置），并且每个元素的值小于64字节，redis会使用整数集合</li> <li>其他情况用哈希表</li></ul> <h3 id="命令-4"><a href="#命令-4" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h3> <p>适用于数据去重和保障数据的唯一性，统计集合交并集等</p> <p>但set求差并交的计算复杂度较高，容易造成阻塞，因此在主从集合中，可以用从库完成聚合统计、或者返回给客户，客户端完成聚合统计</p> <p>1、点赞</p> <p>set能保证一个用户只能点一个赞，例如key是文章id，value是用户id</p> <p>2、共同关注</p> <p>用交集运算计算共同关注的好友、公众号</p> <p>3、抽奖活动</p> <p>存储活动中中奖的用户名，确保不会一个用户中奖两次，随机取函数可以用于抽奖</p> <h2 id="zset类型"><a href="#zset类型" class="header-anchor">#</a> ZSet类型</h2> <h3 id="底层实现-4"><a href="#底层实现-4" class="header-anchor">#</a> 底层实现</h3> <p>底层用压缩列表或跳表，比起set多了排序属性，每个元素由两个值构成，一个是排序（score）值，一个是元素值</p> <ul><li>集合的元素&lt;128个（可配置），并且每个元素的值小于64字节，redis会使用压缩列表</li> <li>其他情况用跳表</li></ul> <p>redis 7.0后压缩列表用listpack实现</p> <h3 id="命令-5"><a href="#命令-5" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景-5"><a href="#应用场景-5" class="header-anchor">#</a> 应用场景</h3> <p>Zset类型可以根据元素的权重来排序，面对需要分页展示最新列表（以时间作为权重）、排行榜等场景</p> <p><strong>排行榜</strong></p> <p>以博文点赞排名，</p> <p>对于新增一个点赞，可以用<code>ZINCRBY user:xiaolin:ranking 1 arcticle:4</code></p> <p>查看赞数，可以用<code>ZSCORE user:xiaolin:ranking arcticle:4</code></p> <p>获取赞数最多的三篇文章，<code>ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</code></p> <p><strong>电话、姓名排序</strong></p> <h2 id="bitmap"><a href="#bitmap" class="header-anchor">#</a> BitMap</h2> <p>位图，适用于数据量大且使用二值统计的场景</p> <h3 id="内部实现"><a href="#内部实现" class="header-anchor">#</a> 内部实现</h3> <p>本身用string类型作为底层数据结构，string保存为二进制的字节数组</p> <h3 id="命令-6"><a href="#命令-6" class="header-anchor">#</a> 命令</h3> <h3 id="应用场景-6"><a href="#应用场景-6" class="header-anchor">#</a> 应用场景</h3> <p><strong>签到统计</strong></p> <p>记录一个用户的签到情况</p> <p>记录该用户，6月3号（3的下标是2）的签到值为1  <code>SETBIT uid:sign：100:202206 2 1</code></p> <p>检查该用户6月3号是否签到 <code>GETBIT uid:sign:100 :202206 2</code></p> <p>统计该用户在6月的签到次数      <code>BITCOUNT uid:sign：100:202206</code></p> <p><strong>判断用户登录态</strong></p> <p>对于5000万用户只需6MB空间</p> <p><strong>连续签到用户统计</strong></p> <p>统计连续7天打卡用户总数</p> <p>将每天的日期作为Bitmap的key，userId作为offset，即有7个Bitmap</p> <p>对这7个Bitmap作与运算，得到的Bitmap对应的offset为1就表示这个用户连续7天打卡了</p> <h2 id="hyperloglog"><a href="#hyperloglog" class="header-anchor">#</a> HyperLogLog</h2> <p>统计基数的数据类型，非准确统计，基于概率的统计，误算率为0.81%</p> <p>对于大量的数据的统计所需的内存空间固定且较小，12KB的内存可以算2^64个不同元素的基数</p> <h3 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h3> <h3 id="应用场景-7"><a href="#应用场景-7" class="header-anchor">#</a> 应用场景</h3> <p><strong>百万级网页UV计数</strong></p> <h3 id="geo"><a href="#geo" class="header-anchor">#</a> GEO</h3> <p>存储地理位置</p> <h3 id="内部实现-2"><a href="#内部实现-2" class="header-anchor">#</a> 内部实现</h3> <p>使用了Sorted Set集合类型，实现了经纬度到Sorted Set集合中的权重分数的转换</p> <p>对二维地图作区间划分，并对区间进行编码</p> <h3 id="应用场景-8"><a href="#应用场景-8" class="header-anchor">#</a> 应用场景</h3> <p>滴滴打车</p> <h2 id="stream"><a href="#stream" class="header-anchor">#</a> stream</h2> <p>专门为消息队列设计的数据类型</p> <p>传统的消息队列存在一些问题：</p> <ul><li>发布订阅模式不能持久化，对于离线重连的客户端不能读取消息</li> <li>list实现消息队列的方式不能重复消费，消费后就会被删除，并且生产者需要自行实现全局唯一ID</li></ul> <p>@发布订阅模式为什么不能作为消息队列</p> <ul><li>发布/订阅机制没有基于数据类型实现，所以不会写入RDB和AOF中，不具备数据持久化的能力</li> <li>订阅者离线重连后不能消费之前的历史消息</li> <li>消费端有消息积压时，如果超过32M或60s保持8M以上，消费端会被强行断开</li></ul> <p>所以，发布/订阅机制只适合即时通讯的场景</p> <h3 id="命令使用"><a href="#命令使用" class="header-anchor">#</a> 命令使用</h3> <h3 id="应用场景-消息队列"><a href="#应用场景-消息队列" class="header-anchor">#</a> 应用场景-消息队列</h3> <p>插入成功的数据会返回全局唯一的ID，这个ID第一部分为当前服务器的时间，第二部分为当前ms内的消息序号，从0开始编号</p> <p><strong>消费组</strong></p> <p>消息队列中的消息一旦被消费组读取了，就不能再被该消费组的其他消费者读取，但不同消费组的消费这可以消费同一条消息</p> <p>使用消费组可以让多个消费者分担读取消息</p> <p>@ 如何保证消费者发生故障重启后仍能读取未处理完的消息</p> <p>streams会自动使用内部队列（PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用XACK命令通知streams消息处理完成</p> <p>@ stream消息会丢失吗</p> <p>在生产者和消费者部分不会丢失消息，在中间件部分会丢失：</p> <ul><li>AOF持久化配置为每秒写盘，这个过程是异步的，redis宕机时可能丢失数据</li> <li>主从复制也是异步的，主从切换时可能丢失数据</li></ul> <p>像RabbitMQ或Kafka这类专业的队列中间件，生产者发布消息时，中间件会写多个节点，一个节点挂了集群数据不丢失</p> <p>@stream消息可堆积吗</p> <p>redis作为内存数据库，消息积压超过内存上限会面临OOM风险，所以redis的stream提供指定队列最大长度的功能，超过上限时，旧消息会被删除</p> <p><strong>因此将redis作为消息队列使用可能面临：</strong></p> <ul><li>redis的数据丢失</li> <li>面对消息挤压，内存资源紧张</li></ul> <p>因此如果业务简单，可以使用，但如果业务有海量消息，不能接收数据丢失，应该用专业的消息队列中间件</p> <h1 id="redis线程模型"><a href="#redis线程模型" class="header-anchor">#</a> redis线程模型</h1> <p>redis的线程：</p> <p>主线程完成：接收客户端请求-&gt;解析请求-&gt;数据读写-&gt;发送给客户端</p> <ul><li><p>bio_close_file线程：处理关闭文件</p></li> <li><p>bio_aof_fsync线程：负责AOF刷盘</p></li> <li><p>bio_lazy_free线程：来释放redis内存</p></li></ul> <p>redis 6.0后引入三个I/O多线程： io_thd_1、io_thd_2、io_thd_3：</p> <p>即，默认情况下加上主线程有7个线程</p> <p>后台线程的任务操作都很耗时，因此有单独的线程完成</p> <p>生产者把耗时任务丢到任务队列中，后台线程相当于消费者轮询队列处理</p> <h2 id="redis单线程模式"><a href="#redis单线程模式" class="header-anchor">#</a> redis单线程模式</h2> <p>redis 6.0之前的单线程模式</p> <p>通过epoll接收客户端的相应，事件分发器生成对应的连接事件、读事件、写事件，主线程做事件循环依次处理事件</p> <p><img src="/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20231103202713648.png" alt="蓝色部分为事件循环"></p> <h3 id="事件循环函数"><a href="#事件循环函数" class="header-anchor">#</a> <strong>事件循环函数</strong></h3> <p>调用处理发送队列函数：对于这一轮，如果有发送任务，通过write函数将客户端缓冲区的数据发送出去，如果没有，注册写事件处理函数，epoll_wait函数发现事件后再处理</p> <p>接着，调用epoll_wait函数等待事件</p> <ul><li>对于连接事件，调用连接事件处理函数
<ul><li>调用accpet获取已连接的socket</li> <li>调用epoll_ctl将已连接的socket加入到epoll</li> <li>注册读事件处理函数</li></ul></li> <li>对于读事件，调用读事件处理函数
<ul><li>调用read获取发来的数据</li> <li>解析命令</li> <li>处理命令</li> <li>将客户端对象添加到发送队列</li> <li>将执行结果写入发送缓存区</li></ul></li> <li>对于写事件，调用写事件处理函数
<ul><li>通过write函数将客户端发送缓存区的数据发送出去，</li> <li>如果这一轮数据没有发完，继续注册写事件处理函数，等待epoll_wait发现后再处理</li></ul></li></ul> <h3 id="redis为什么使用单线程"><a href="#redis为什么使用单线程" class="header-anchor">#</a> redis为什么使用单线程</h3> <p>redis吞吐量可以达到10W/s</p> <p><strong>redis的单线程为什么快</strong></p> <ol><li>大部分操作在内存中完成+高效的数据结构</li> <li>单线程模型避免了多线程的竞争和切换开销</li> <li>I/O多路复用机制</li></ol> <p><strong>redis 6.0前为什么用单线程</strong></p> <p>redis的性能瓶颈并不是CPU，更多时候是内存大小和网络I/O的限制，因此采用单线程即可（多线程会使得CPU性能过剩）</p> <p>如果要使用多线程，则可以在一台服务器上启动多个节点或采用分片集群</p> <p>单线程易于维护，不会产生并发读写的问题，不会有线程切换竞争等损耗</p> <h3 id="为什么引入了多线程"><a href="#为什么引入了多线程" class="header-anchor">#</a> 为什么引入了多线程</h3> <p>网络硬件性能的提升使得redis的性能瓶颈有时在网络I/O的处理上</p> <p>redis 6.0用多线程处理网络I/O，对于命令依然是单线程处理</p> <p>可以通过配置文件修改多线程的使用，默认只针对发送响应数据，不会以多线程的方式处理读请求</p> <p>线程的数量，官方建议是小于机器核数，8核则分配6个线程即可（加上主线程7个）</p> <h1 id="持久化"><a href="#持久化" class="header-anchor">#</a> 持久化</h1> <h2 id="主要实现方式"><a href="#主要实现方式" class="header-anchor">#</a> 主要实现方式</h2> <ul><li>AOF日志：每执行一条写操作，将命令以追加的方式写入到一个文件里</li> <li>RDB快照：将某一时刻的内存数据以二进制的方式写入磁盘</li> <li>混合持久化方式：结合上面两种</li></ul> <h2 id="aof日志"><a href="#aof日志" class="header-anchor">#</a> AOF日志</h2> <p>每执行一条写操作，将命令追加写入一个文件，文件内容</p> <h3 id="aof日志格式"><a href="#aof日志格式" class="header-anchor">#</a> AOF日志格式</h3> <img src="image-20231103212947132.png" alt="image-20231103212947132" style="zoom:50%;"> <p>*3   表示当前命令有三个部分</p> <p>$数字 表示一个部分的开头，后面跟着命令\键\值，数字表示这部分的有多少字节</p> <p>@ <strong>为什么先执行命令，再写入</strong></p> <ul><li>先记录再执行，如果执行失败（语法失败），那么用日志恢复时就会出错</li> <li>单线程执行，不会阻塞写操作的执行</li></ul> <p><strong>@ 带来的风险</strong></p> <ul><li>数据可能丢失</li> <li>单线程执行，可能阻塞其他操作</li></ul> <h3 id="aof写回策略"><a href="#aof写回策略" class="header-anchor">#</a> AOF写回策略</h3> <p>执行写操作命令，将命令追加到server.aof_buf缓冲区，IO系统调用write，写入内核缓冲区的AOF文件，内核发起写操作进入硬盘</p> <p>redis的三种写回硬盘策略</p> <ul><li>Always：每次写操作都同步AOF到硬盘</li> <li>everysec：每次写操作后都写入AOF内核缓冲区，每隔一秒写到硬盘</li> <li>NO：不由redis控制写硬盘的时机，os决定</li></ul> <h3 id="aof重写机制"><a href="#aof重写机制" class="header-anchor">#</a> AOF重写机制</h3> <p>AOF日志过大时会带来性能问题，恢复很慢</p> <p>因此当AOF文件大小超过设定的阔值后，启动AOF重写机制，压缩AOF文件</p> <p><strong>原理</strong>：在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到新的AOF文件，全部记录完成后，用新的AOF文件替换掉旧的AOF</p> <p><strong>例如：</strong></p> <p>旧文件先后执行了[set name xiaolin] 和 [set name xiaolincoding]这两个命令</p> <p>重写机制后，合为一条命令[set name xiaolincoding]</p> <p><strong>重写AOF日志的过程</strong></p> <p>重写过程由后台子进程bgrewriteaof来完成，而不是线程，这样做的优势：</p> <p>使用多个线程对共享内存的修改会涉及到加锁，降低性能，
而子进程以只读的方式共享父进程的数据，当父子进程任意一方修改了该共享内存就会发送写时复制，不需要加锁</p> <p>触发重写机制后，重写子进程以只读的方式读取数据库里的所有数据，逐一把内存数据的键值对转换为一条命令，再将命令记录到新的AOF</p> <p>@ 对于重写过程中，主进程的记录修改如何记录到新的AOF？</p> <p>redis采用了<strong>AOF重写缓冲区</strong>，创建了bgrewriteaof子进程后开始使用，当redis执行完一个写命令后，会同时将这个写命令写入到AOF缓冲区和AOF重写缓冲区</p> <p>在bgrewriteaof子进程执行AOF重写期间，主进程需要执行以下三个工作：</p> <ul><li>执行客户端发来的命令</li> <li>将执行后的写命令追加到AOF缓冲区</li> <li>将执行后的写命令追加到AOF重写缓冲区</li></ul> <p>子进程完成AOF重写规则后，向主进程发送信号</p> <p>主进程收到信号后：</p> <ul><li>将AOF重写缓冲区的所有内容追加到新的AOF的文件</li> <li>新的AOF文件进行改名，覆盖现有的AOF文件</li></ul> <hr> <h2 id="rdb快照"><a href="#rdb快照" class="header-anchor">#</a> RDB快照</h2> <p>对于故障恢复，AOF以记录操作命令的方式恢复数据比较缓慢</p> <p>RDB记录某一瞬间的内存数据，恢复时直接将RDB文件读入内存即可，恢复数据效率较高</p> <h3 id="快照的线程阻塞机制"><a href="#快照的线程阻塞机制" class="header-anchor">#</a> 快照的线程阻塞机制</h3> <p>redis提供了三种方案决定以什么样的方式执行快照记录</p> <ul><li>save命令，将在主线程生成RDB文件，写入时间过长会阻塞线程</li> <li>bgsave命令，创建子进程来生成RDB文件，避免主线程阻塞</li> <li>通过配置文件的选项来实现隔一段时间自动执行依次bgsave命令</li></ul> <p>redis是全量快照，每次执行都是把内存的所有数据记录到磁盘中，所以如果频率太频繁会对性能有影响</p> <p>@ RDB在执行快照时数据能修改吗</p> <p>依托写时复制技术，可以边记录边修改，即父子进程的实现机制</p> <h2 id="混合持久化"><a href="#混合持久化" class="header-anchor">#</a> 混合持久化</h2> <p>RDB恢复数据快，但快照的频率不能太高，使得安全性较低，AOF丢失数据少但数据恢复不快</p> <p>开启了混合持久化时，在AOF重写日志时，重写子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，
此时主线程处理的操作记录记录到重写缓冲区里，重写缓冲区里的增量命令以AOF方式写入到AOF文件，
写入完成后通知主进程将RDB格式和AOF格式的AOF文件替换旧的AOF文件</p> <p>即混合持久化生成的文件，前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据</p> <p><strong>优点</strong>：恢复速度很快，丢失更少的数据</p> <p><strong>缺点</strong>：AOF中添加了RDB格式使得可读性变差、兼容性差，不能用于redis以前的版本</p> <h1 id="redis集群"><a href="#redis集群" class="header-anchor">#</a> redis集群</h1> <h2 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h2> <p>将一台redis服务器同步数据到多台服务器上，主从服务器间采用读写分离</p> <p>主服务器进行读写操作，写操作自动将写同步给从服务器，从服务器一般只读</p> <p>主从服务器的同步过程是异步的：</p> <p>主服务器收到新的写命令后，发送给从服务器，然后就向客户端返回结果了，因此主从服务器间的数据不一致，即属于ap</p> <h2 id="哨兵模式"><a href="#哨兵模式" class="header-anchor">#</a> 哨兵模式</h2> <p>当redis的主从服务器出现故障时，需要手动进行恢复，为解决这个问题增加了哨兵模式，可以监控主从服务器，提供主从节点故障转移的功能</p> <h2 id="切片集群模式"><a href="#切片集群模式" class="header-anchor">#</a> 切片集群模式</h2> <p>当redis缓存数据量大到一台服务器无法缓存时，使用集群模式将数据分布在不同的服务器上，以降低对单节点的依赖，从而提高读写性能</p> <p>redis cluster采用<strong>哈希槽</strong>来处理数据和节点之间的映射关系，一个切片集群有16384个哈希槽（2^14），每个键值对都会根据它的key映射到一个哈希槽中：</p> <ul><li>根据键值对的key，按照CRC16（循环冗余校验）算法计算一个16bit的值</li> <li>再用16bit值对16384取模，每个模数代表一个编号的哈希槽</li></ul> <p>哈希槽与具体redis节点的映射关系：</p> <ul><li>平均分配：自动把哈希槽平均分布到集群节点上</li> <li>手动分配：手动建立节点间的连接，组成集群，指定每个节点上的哈希槽个数</li></ul> <p>手动分配时，需要把16384个槽全部分配完</p> <hr> <p>@ 什么是集群脑裂（双主现象）</p> <p>如果主节点A网络发生问题与所有从节点失联，和客户端网络正常，此时客户端的数据写入只缓存到了主节点A，无法同步给从节点</p> <p>脑裂引发的数据丢失问题</p> <p>哨兵发现主节点A失联，重新选举出一个leaderB，然后网络突然好了，旧主节点A降为从节点，从节点A向新主节点请求数据同步，第一次为全量同步，此时节点A清空字节的本地数据，从而之前客户端写入A的数据丢失</p> <hr> <p>@ 解决脑裂引发的数据丢失问题</p> <p>客户端向主节点的写请求，主节点必须满足如下两个条件：</p> <ul><li>主节点必须有x个从节点连接，小于这个数会禁止写</li> <li>主从数据复制和同步的延迟不能超过x秒，超过会禁止写</li></ul> <p>如果不满足会直接返回错误给客户端</p> <h1 id="过期删除策略"><a href="#过期删除策略" class="header-anchor">#</a> 过期删除策略</h1> <p>对key设置过期时间，redis会把key带上过期时间存储到一个过期字典</p> <p>当查询key时，redis会先检查这个key是否存在于过期字典中</p> <p>不在，正常读值，在，则获取过期时间，与当前系统时间进行对比，判定是否过期</p> <blockquote><p>redis使用的过期删除策略是惰性删除+定期删除</p></blockquote> <h2 id="惰性删除策略"><a href="#惰性删除策略" class="header-anchor">#</a> 惰性删除策略</h2> <p>不主动删除过期键、每次从数据库访问key时，检测key是否过期，过期则删除该key</p> <p>优点：占用系统最少的资源，性能好</p> <p>缺点：过期key留在数据库中，一直不被访问，造成了内存空间的浪费</p> <h2 id="定期删除策略"><a href="#定期删除策略" class="header-anchor">#</a> 定期删除策略</h2> <p>每隔一段时间随机从数据库取出一定数量的key进行检查，删除过期key</p> <p>定期删除的流程：</p> <ol><li>从过期字典中随机抽取20个key检查是否过期，删除过期的key</li> <li>如果过期的数量超过5个（1/4），则重复步骤1</li> <li>如果过期数量小于1/4则停止，等待下一轮再检查</li></ol> <p>为保证不循环过度，增加了定期删除循环流程的时间上限为不超过25ms</p> <p>优点：控制删除的时长和频率，来减少删除操作对CPU的影响</p> <p>缺点：难以确定删除操作执行具体的时长和频率，需要在CPU和内存占用作权衡</p> <h2 id="持久化时-对于过期键如何处理"><a href="#持久化时-对于过期键如何处理" class="header-anchor">#</a> 持久化时，对于过期键如何处理</h2> <h3 id="rdb文件"><a href="#rdb文件" class="header-anchor">#</a> RDB文件</h3> <p>对于RDB文件生成阶段：</p> <p>从内存状态持久化为RDB时，会对key进行过期检查，过期的键不会被保存到新的RDB文件中</p> <p>对于RDB加载阶段：</p> <p>如果redis是主服务器运行模式，载入RDB文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中</p> <p>如果redis是从服务器运行模式，载入RDB文件时，不论键是否过期都会载入。但主从服务器在进行数据同步时覆盖了从服务器的数据，所以不会造成影响</p> <h3 id="aof文件"><a href="#aof文件" class="header-anchor">#</a> <strong>AOF文件</strong></h3> <p>对于AOF写入阶段：</p> <p>如果某个过期键还没被删除，会保留次过期键，过期键删除后会向AOF追加DEL命令来显式的删除该键值</p> <p>对于AOF重写阶段：</p> <p>会对redis中的键值进行检查，已过期的键不会被保存到重写后的AOF文件</p> <h2 id="主从模式中-对过期键的处理"><a href="#主从模式中-对过期键的处理" class="header-anchor">#</a> 主从模式中，对过期键的处理</h2> <p>从库不会过期扫描，主库在key到期时往AOF文件里增加一条del指令，同步所有从库，从库通过执行这条del指令来删除过期的key</p> <h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="header-anchor">#</a> 内存淘汰机制</h2> <p>当运行内存达到了阔值，就会触发内存淘汰机制</p> <p><strong>不进行数据淘汰</strong>：运行内存超过最大设置则不再提供服务</p> <p><strong>进行数据淘汰</strong>：</p> <p>对设置了过期时间的数据中进行淘汰：</p> <div class="language- extra-class"><pre><code>- 随机淘汰设置了过期时间的任意键值
- 优先淘汰更早过期的键值
- 淘汰所有设置了过期时间的键值中最久未使用的LRU
- （默认）淘汰所有设置了过期时间的键值中最少使用的LFU
</code></pre></div><p>对所有数据范围内进行淘汰：</p> <ul><li>随机淘汰任意键值</li> <li>淘汰整个键值中最久未使用的键值LRU</li> <li>（默认）淘汰整个键值中最少使用的键值LFU</li></ul> <h3 id="删除策略"><a href="#删除策略" class="header-anchor">#</a> 删除策略</h3> <p>对于一些key设置了过期时间，使用<code>惰性删除+定期删除</code>的删除策略</p> <p>定时删除：（redis没有）每个数据都定时一个删除任务</p> <p>**惰性删除：**每次数据库访问key时，检查是否过期，过期删除（性能好，但没有及时删除，有内存浪费）</p> <p>**定期删除：**定时检查一定数量的key执行删除</p> <ol><li>随机抽20个key检查并执行过期删除</li> <li>过期的数量超过1/4，则重复步骤1，否则停止</li> <li>循环上限不超过25ms</li></ol> <p>持久化为RDB文件或通过RDB文件加载时，会对每个键作过期检查</p> <p>持久化AOF文件，删除操作会追加一条删除命令写入</p> <p>从库通过主库发出的del命令执行删除</p> <h3 id="lru算法-redis4-0前使用"><a href="#lru算法-redis4-0前使用" class="header-anchor">#</a> LRU算法(redis4.0前使用)</h3> <p>利用链表实现最近最少未使用的数据，存在两个问题：</p> <ul><li>链表的管理有额外开销</li> <li>数据被访问需要移动链表，大量的移动会带来很多链表的移动操作，降低性能</li></ul> <p>redis的实现在对象结构体添加一个额外字段，用于记录此数据的最后一次访问时间</p> <p>当redis进行内存淘汰时，随机取5个值，淘汰最久没有使用的那个</p> <p>优点：不用维护链表，节省了空间占用 | 不同每次访问都移动链表，提升了性能</p> <p>缺点：无法解决缓存污染，一次读取大量数据造成的</p> <h3 id="lfu算法-redis4-0后默认-最近最不常用"><a href="#lfu算法-redis4-0后默认-最近最不常用" class="header-anchor">#</a> LFU算法（redis4.0后默认）最近最不常用</h3> <p>根据数据访问次数来淘汰数据，增加关键字来记录数据访问频次</p> <p>在LRU算法中，lru字段用于记录key的访问时间戳
在LFU算法中，lru字段，高16位用来记录key的访问时间戳，低8位存储logc，记录访问频次</p> <h1 id="redis缓存设计"><a href="#redis缓存设计" class="header-anchor">#</a> redis缓存设计</h1> <p>redis作为缓存数据库直接在内存运行，有更高的查询效率，避免直接在磁盘访问</p> <p>为了保证缓存的数据和数据库中的数据一致性，会给redis的数据设置过期时间，过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此会访问数据库，将数据更新到redis里，后续请求可以直接命中缓存</p> <h2 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> 缓存雪崩</h2> <p>当大量缓存在同一时间过期时，面对大量的用户请求，需要大量直接访问数据库，从而增大数据库压力，进一步会造成数据库宕机</p> <p>解决：</p> <ul><li>随机打散缓存失效时间：在原有的失效时间上增加一个随机值</li> <li>设置缓存不过期：通过后台服务来更新缓存数据</li></ul> <h2 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h2> <p>缓存击穿可以是缓存雪崩的子集</p> <p>有时有几个数据会被频繁访问，例如秒杀活动，这类数据被称为<strong>热点数据</strong></p> <p>如果热点数据过期了，大量的请求访问了该热点数据，无法在缓存中命中，直接访问数据库从而使得数据库很容易被冲垮</p> <p>解决：</p> <ul><li>互斥锁保证同一时间只有一个业务线程请求数据库</li> <li>不给热点数据设置过期时间，由后台异步更新缓存，在热点数据要过期前，通知后台线程更新缓存即重新设置过期时间</li></ul> <h2 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> 缓存穿透</h2> <p>用户访问的数据既不在缓存，也不在数据库中，此时无法构建缓存数据，当大量的这样的请求到来，造成数据库压力增大</p> <p><strong>通常原因</strong>：</p> <p>黑客恶意攻击，故意大量访问读取不存在的数据</p> <p>业务误操作，将数据库中的数据误删除了</p> <p><strong>解决</strong></p> <ol><li>非法请求的限制：判断请求参数是否合理</li> <li>设置空值或者默认值：对查询的数据设置空值或默认值，后续查询从缓存中取到空值</li> <li>l使用布隆过滤器快速判断数据是否存在，避免查询数据库：</li></ol> <h2 id="如何设计动态缓存热点数据"><a href="#如何设计动态缓存热点数据" class="header-anchor">#</a> 如何设计动态缓存热点数据</h2> <p>对于一些key设置了过期时间，使用<code>惰性删除+定期删除</code>的删除策略</p> <p>定时删除：（redis没有）每个数据都定时一个删除任务</p> <p>**惰性删除：**每次数据库访问key时，检查是否过期，过期删除（性能好，但没有及时删除，有内存浪费）</p> <p>**定期删除：**定时检查一定数量的key执行删除</p> <ol><li>随机抽20个key检查并执行过期删除</li> <li>过期的数量超过1/4，则重复步骤1，否则停止</li> <li>循环上限不超过25ms</li></ol> <p>持久化为RDB文件或通过RDB文件加载时，会对每个键作过期检查</p> <p>持久化AOF文件，删除操作会追加一条删除命令写入</p> <p>从库通过主库发出的del命令执行删除</p> <p>改进的LRU机制</p> <ol><li><p>通过缓存系统作排序队列，最近访问的越靠前，存放最常访问的1000个商品</p></li> <li><p>定期过滤队列后200个，从数据库随机取200个加入队列</p></li> <li><p>请求到达，先取商品ID，命中就根据ID从另一个缓存数据结构中读取实际的商品信息</p></li></ol> <h2 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="header-anchor">#</a> 常见的缓存更新策略</h2> <h3 id="cache-aside-旁路缓存-策略"><a href="#cache-aside-旁路缓存-策略" class="header-anchor">#</a> Cache Aside（旁路缓存）策略</h3> <p>实际中redis和mysql都使用这个策略</p> <p><strong>对于写</strong></p> <p>先更新数据库的数据，再删除缓存的数据</p> <p>不能反过来，先删缓存再更新数据库会找出读写并发时出现缓存和数据库不一致</p> <ul><li>B读取数据a，缓存没命中，请求查询数据库</li> <li>A想更新数据a，删除缓存</li> <li>B得到a的旧值加入缓存</li> <li>A更新数据库的数据为新值，</li> <li>此时缓存的数据和数据库的数据不一致，将一直保持下去直到缓存失效</li></ul> <p>而先更新数据库再删除也会出现，但概率不高</p> <ul><li>B读取数据a，缓存没命中，请求查询数据库，得到旧值为20</li> <li>A想更新数据a，更新数据库为21</li> <li>A更新完数据库，删除缓存</li> <li>B将旧值写入缓存</li></ul> <p>对于步骤3和4，通常更新数据库比缓存的写入要慢，所以通常步骤4会先于步骤3发生</p> <p>如果要彻底解决这个问题：</p> <ol><li>更新值前加分布式锁，同一时间只允许一个线程更新，这会带来写入性能问题</li> <li>给缓存上租约，即使出现缓存不一致，也会很快过期，对业务的影响可接收</li></ol> <p><strong>对于读</strong></p> <p>命中缓存则返回，没命中则从数据库读数据再写入缓存</p> <p>该策略适合读多写少，不适合写多的场景，写入频繁会使得缓存的数据频繁改变，从而缓存命中率低</p> <h3 id="read-write-through-读穿-写穿-策略"><a href="#read-write-through-读穿-写穿-策略" class="header-anchor">#</a> Read/Write Through(读穿/写穿)策略</h3> <p>应用程序只和缓存交互，缓存和数据库交互</p> <p><strong>对于读</strong></p> <p>查询缓存数据是否存在，存在则返回，不存在则由缓存组件从数据库查询，并写入缓存组件，缓存组件将数据返回给应用</p> <p><strong>对于写</strong></p> <p>先查询数据在缓存中是否存在，如果存在则更新缓存数据并同步更新数据库，然后缓存组件返回更新完成
如果不存在，更新数据库后返回</p> <p>开发中使用较少，因为常用的分布式缓存组件，例如memcached和redis都不提供和数据库交互的功能，对于我们自己写本地缓存可以使用这种策略</p> <h3 id="write-back-写回-策略"><a href="#write-back-写回-策略" class="header-anchor">#</a> Write Back（写回）策略</h3> <p>更新数据时只更新缓存，将缓存数据设置为脏并返回，不会更新数据库。对于数据库的更新会通过批量异步的方式进行</p> <p>这种方式常用于计算机体系结构中的设计，如CPU的缓存、os中文件系统的缓存</p> <p>适用写多的场景，但数据不是强一致性的，并且如果断电有数据丢失的风险</p> <h1 id="redis实战"><a href="#redis实战" class="header-anchor">#</a> redis实战</h1> <h2 id="如何实现延迟队列"><a href="#如何实现延迟队列" class="header-anchor">#</a> 如何实现延迟队列</h2> <p>将当前要做的事情推迟一段时间再做，</p> <ul><li>淘宝下单超过一定时间未付款订单自动取消</li> <li>外卖商家10分钟没有接单会自动取消订单</li></ul> <p>使用有序集合ZSet的方式来实现延迟消息队列，其中有score属性来存储延迟执行的时间</p> <h2 id="对于大key如何处理"><a href="#对于大key如何处理" class="header-anchor">#</a> 对于大key如何处理</h2> <p>即key对应的value很大，例如：</p> <ul><li>string类型的值大于10KB</li> <li>hash、list、set、zset类型的元素个数超5000个</li></ul> <p><strong>大key会带来的问题</strong></p> <ul><li><strong>客户端超时阻塞</strong>，单线程的redis操作大key比较耗时，造成redis阻塞</li> <li><strong>引发网络阻塞</strong>， 如果大key的大小为1M，每秒访问量为1000，对于千兆网卡来说难以应对</li> <li><strong>内存分布不均</strong>，集群模型在slo分片均匀情况下，出现数据和查询倾斜，部分大key的节点占用内存多</li></ul> <p><strong>如何找到大key</strong></p> <ul><li><p>这个命令会占用较多CPU，因此最后在从节点上运行，避免阻塞主节点。同时在业务压力低峰节点扫描检查</p></li> <li><p>只能返回每种类型中最大的bigkey</p></li> <li><p>对于集合类型，只能统计元素个数，不能统计每个元素的大小</p></li></ul> <p>用sacn命令查找，用rdbtools工具查找</p> <p><strong>如何删除大key</strong></p> <p>删除会释放这个内存空间，os会将其插入空闲内存块的链表，这个过程比较耗时，会阻塞当前释放内存的应用</p> <ul><li>分批次删除</li></ul> <p>对于hash，用hscan每次获取100个字段，再用hdel每次删除一个字段</p> <ul><li>异步删除</li></ul> <p>用unlink代替del</p> <p>也可以通过配置在一些场景下开启自动异步删除</p> <ul><li>lazyfree-lazy-eviction : 当运行内存超过maxmeory开启</li> <li>lazyfree-lazy-expire：对于设置了过期时间的键值，过期之后是否开启</li> <li>lazyfree-lazy-server-del：一些指令内存实现带有隐式的del操作（比如rename），在这种场景下是否开启</li> <li>slave-lazy-flush：从节点作数据同步时，在加载master的RDB文件时，会先清理自己的数据，在时是否开启</li></ul> <h2 id="redis管道的作用"><a href="#redis管道的作用" class="header-anchor">#</a> redis管道的作用</h2> <p>管道是客户端提供的批处理技术用于一次处理多个redis命令，将多个命令整合到一起发送给服务端处理后统一返回。要避免发送的命令过大而阻塞网络</p> <h2 id="redis事务支持回滚吗"><a href="#redis事务支持回滚吗" class="header-anchor">#</a> redis事务支持回滚吗</h2> <p>没有提供回滚，事务的执行，对于已经正确执行的部分，当当前事务终止，不能回退正确执行的部分，即并不保证事务的原子性</p> <p>原因是，redis事务的执行一般不会发生错误，通常错误都是由编程错误导致，而非实际应用出现，不需要增加这个功能</p> <p>同时事务回滚这种复杂的功能违背了redis追求的简单高效</p> <h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="header-anchor">#</a> redis实现分布式锁</h2> <p>用string类型存放锁，需要满足三个条件</p> <ol><li>set命令带上nx选项来实现读取并写入锁值</li> <li>锁要设置过期时间，避免客户端拿到锁后发生异常导致锁一直无法释放，EX/PX选项</li> <li>锁变量要能区分不同客户端的加锁操作</li></ol> <p><code>set lock_key unique_value NX PX 10000</code></p> <p>对于解锁，需要先比较客户端unique_value的值再修改值，这个过程使用Lua脚本保证操作的原子性</p> <p>优点：</p> <ol><li>性能高效</li> <li>实现方便</li> <li>避免单点故障（redis是跨集群部署的）</li></ol> <p>缺点：</p> <ol><li><p>超时时间不好设置，过长影响性能，过短无法保护到共享资源</p> <p>可以基于续约的方式设置超时时间，启动应该守护线程，在一段时间后重置这个锁的超时时间，主线程执行完后，终止这个守护线程</p></li> <li><p>主从复制模式中的数据是异步复制的，这将导致分布式锁的不可靠。如果主节点获取到锁后没有同步到其他节点时redis主节点宕机了，此时新的redis主节点依然可以获取锁</p></li></ol> <hr> <p><strong>@红锁：</strong></p> <p>为了解决集群下分布式锁的可靠性问题，redis提供了分布式锁算法redlock（红锁）</p> <p>官方推荐部署5个redis主节点，均为孤立节点，让客户端和多个独立的redis节点依次请求申请加锁，如果过半能完成加锁操作就认为能够加锁，否则加锁失败</p> <p>redlock算法加锁的三个过程</p> <ol><li>客户端获取当前时间t1</li> <li>客户端按顺序依次向N个redis节点执行加锁操作，同时加锁操作设置一个时间上限（避免某个节点发生故障时，redlock依然能正常运行，通常为几十ms）</li> <li>如果过半获取到了锁，再获取当前时间（t2），计算整个加锁的总耗时（t2-t1)，</li> <li>如果获取锁的总耗时小于锁设置的过期时间，并且剩下的时间能够完成数据的操作则成功获取到了锁，否则认为锁过期</li> <li>如果加锁失败，客户端向所有redis节点发起释放锁的操作</li></ol></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/liang9886703/edit/master/docs/05.数据库/01.redis原理.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2025/02/13, 23:35:20</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/05/02/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">数据库</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/05/02/">数据库</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/02/01/"><div>
            一致性算法
            <!----></div></a> <span class="date">02-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/01/01/"><div>
            vim
            <!----></div></a> <span class="date">02-13</span></dt></dl><dl><dd>03</dd> <dt><a href="/02/02/"><div>
            分布式ID生成
            <!----></div></a> <span class="date">02-13</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:liang9886703@outlook.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/liang9886703" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2025-2025
    <span>松垮垮 | <a href="https://github.com/liang9886703/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a> | <a href="http://beian.miit.gov.cn/" target="_blank">蜀ICP备2025120453号</a> | <img src="/img/beian.png" style="width: 15px; margin-bottom: -3px;" /> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=51011202000997" rel="noreferrer" target="_blank">川公网安备51011202000997号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          纯净模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center  top / 90% 90% no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.41210a84.js" defer></script><script src="/assets/js/2.ddcc22d9.js" defer></script><script src="/assets/js/3.9a514af0.js" defer></script><script src="/assets/js/30.0fbcfcdc.js" defer></script>
  </body>
</html>
