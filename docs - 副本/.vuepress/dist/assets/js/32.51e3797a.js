(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{400:function(_,t,v){"use strict";v.r(t);var e=v(7),a=Object(e.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"nginx作为反向代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx作为反向代理"}},[_._v("#")]),_._v(" nginx作为反向代理")]),_._v(" "),t("blockquote",[t("p",[_._v("通常nginx能作为反向代理服务器和静态web服务器")])]),_._v(" "),t("p",[_._v("对于一组请求，nginx会将请求完整的缓存到代理服务器，再向上游服务器转发。这是为了如果接到请求就和上游服务器建立连接，当用户请求传输的数据很大，且用户请求转发走公网速度较慢，上游服务器这个连接在很长时间被浪费了。代理服务器缓存完再请求上游服务器，这时走内网速度较快，上游服务器返回数据时代理服务器不缓存直接转发客户端。最终降低了上游服务器的压力，将压力全部由nginx服务器承担")]),_._v(" "),t("h2",{attrs:{id:"http配置项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http配置项"}},[_._v("#")]),_._v(" http配置项")]),_._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[_._v("#")]),_._v(" 原理")]),_._v(" "),t("p",[_._v("执行流程如下，比如对于"),t("code",[_._v("https://aliyuque.antfin.com/gdc_tsc/vlyqvz/wuk85n#176153a")]),_._v("这个地址的请求：")]),_._v(" "),t("ol",[t("li",[_._v("客户端通过url访问服务端时，通常会指定端口如‘http://www.example.com:8080/path_to_file’，如果没有指定端口，浏览器通常会根据协议类型自动使用默认端口。http默认80端口，https默认443端口")]),_._v(" "),t("li",[_._v("通过ip+端口找到服务器后，会根据server_name来找到对应的server，（实际中可能有多个域名对应同一个ip，这个不同域名对应不同的server），那么"),t("code",[_._v("aliyuque.antfin.com")]),_._v("就是一个server")]),_._v(" "),t("li",[_._v("域名后面的部分表示要访问的资源路径，对应一个的location，通过"),t("code",[_._v("gdc_tsc/vlyqvz/wuk85n")]),_._v("定位location")])]),_._v(" "),t("h3",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[_._v("#")]),_._v(" 数据结构")]),_._v(" "),t("p",[t("code",[_._v("nix_module_s")]),_._v(" nginx 模块的控制块")]),_._v(" "),t("p",[t("code",[_._v("ngx_http_module_t")]),_._v(" 读取配置文件时在读取的不同阶段要处理的回调函数")]),_._v(" "),t("p",[t("code",[_._v("ngx_command_s")]),_._v(" 对模块的处理方法")]),_._v(" "),t("p",[_._v("对于http模块处理请求阶段，传入的参数"),t("code",[_._v("ngx_http_request_s")]),_._v("，主要包含以下几部分:")]),_._v(" "),t("ol",[t("li",[_._v("方法名")])]),_._v(" "),t("p",[_._v("​\t通常直接用r->method这个整型成员和宏比较判断，或者用request_start、method_end指向方法名的开始和结束位置")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("URI")])]),_._v(" "),t("ul",[t("li",[_._v("uri_start和uri_end指向URI的开始和结束的下一个位置")]),_._v(" "),t("li",[_._v("extern成员指向用户请求的文件扩展名")]),_._v(" "),t("li",[_._v("unparsed_uri表示没有进行URL解码的原始请求")]),_._v(" "),t("li",[_._v("args_start指向URL参数的起始地址，uri_end指向结束地址")]),_._v(" "),t("li",[_._v("http_protocol指向用户请求中http的起始地址")]),_._v(" "),t("li",[_._v("http_version时nginx解析过的协议版本")]),_._v(" "),t("li",[_._v("request_start和request_end可以获取原始的用户请求行")])]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("获取http头部")])]),_._v(" "),t("p",[_._v("header_in指向nginx收到的未解析的头部，headers_in指向解析后的头部，其中的headerss一个链表，每个节点都是一个kv表，可以通过遍历链表来获取所有http头部")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("获取http包体")])]),_._v(" "),t("p",[_._v("异步接收包体，避免一次性读包体会阻塞nginx进程")]),_._v(" "),t("p",[t("code",[_._v("ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t*r,ngx_http_client_body_handler_pt post_handler);")])]),_._v(" "),t("p",[_._v("当所有包体接受完后，会调用post_handler指向的回调方法，即这个函数返回并不能说明包接受完了")]),_._v(" "),t("p",[_._v("使用了这个函数，那么调用这个函数的上层"),t("code",[_._v("ngx_http_mytest_handler")]),_._v("函数的返回值就要是"),t("code",[_._v("NGX_DONE")])]),_._v(" "),t("h3",{attrs:{id:"模块的配置项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块的配置项"}},[_._v("#")]),_._v(" 模块的配置项")]),_._v(" "),t("h2",{attrs:{id:"nginx模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx模块"}},[_._v("#")]),_._v(" nginx模块")]),_._v(" "),t("p",[_._v("分类为五类：核心模块、mail模块、http模块、conf模块、事件模块，")]),_._v(" "),t("p",[_._v("框架定义核心模块和配置模块，框架使用核心模块，其他模块继承配置模块")]),_._v(" "),t("p",[_._v("核心模块定义了mail、http、事件模块的基础，mail、http、事件模块的基础三类模块中都有一个主要管理的运行模块")]),_._v(" "),t("ul",[t("li",[_._v("所有事件模块由其中的nxg_events_module核心模块定义，ngx_event_core_module模块加载完成")]),_._v(" "),t("li",[_._v("所有http模块由其中的ngx_http_module核心模块定义和加载完成，ngx_http_core_module负责决定具体的请求选择哪个http模块")]),_._v(" "),t("li",[_._v("mail模块和http模块相似")])]),_._v(" "),t("p",[_._v("![image-20240515164555724](/Users/feidi/Library/Application Support/typora-user-images/image-20240515164555724.png)")]),_._v(" "),t("h2",{attrs:{id:"事件驱动架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动架构"}},[_._v("#")]),_._v(" 事件驱动架构")]),_._v(" "),t("p",[_._v("![image-20240515104459058](/Users/feidi/Library/Application Support/typora-user-images/image-20240515104459058.png)")]),_._v(" "),t("p",[_._v("传统的服务器上每个事件消费者独占一个进程资源，主进程处理连接和关闭事件，子进程处理其他事件。nginx是有五类事件由事件分发器感知后短暂调用对应的处理模块，只有事件收集器会独占进程资源。")]),_._v(" "),t("p",[_._v("这带来了更低的用户感知请求时延和并发吞吐，但也要求事件消费者不能有阻塞行为，不然将导致其他事件得不到相应")]),_._v(" "),t("p",[t("strong",[_._v("请求的多阶段异步处理：")])]),_._v(" "),t("p",[_._v("一个请求如果有阻塞的部分，会根据阻塞的点划分成多个阶段：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("将同步变为异步\n比如send数据，第一阶段，事件调用非阻塞的send函数然后退出，当读函数返回结果时会通知事件分发器调用模块处理，开启第二阶段")])]),_._v(" "),t("li",[t("p",[_._v("将长任务分解成多个小任务")]),_._v(" "),t("p",[_._v("有些触发事件不能被事件收集者收集，则只能拆分执行时间")]),_._v(" "),t("p",[_._v("比如，读文件（如果系统不支持异步读，这意味着事件收集者无法感知读完），将10MB划分成1000份，每次读10KB并发送，发送成功后会触发网络事件，从而通知事件收集者调用模块进入下一阶段的读取发送")])]),_._v(" "),t("li",[t("p",[_._v("自旋锁或其他循环等待事件，则使用定时器")]),_._v(" "),t("p",[_._v("有时可能需要持续的检查标志位直到可以继续往下走，此时应该使用定时器来代替循环检查。")]),_._v(" "),t("p",[_._v("定时器事件发生就检查标志，不满足就退出并注册下个定时器")])]),_._v(" "),t("li",[t("p",[_._v("某个阻塞方法没法划分阶段")]),_._v(" "),t("p",[_._v("首先判断这个阻塞是否必要，因为它违反了当前的事件驱动架构，如果必须要，那么")]),_._v(" "),t("p",[_._v("阻塞前和阻塞后由事件分发器调用，当要阻塞时使用一个单独的进程来执行阻塞，阻塞完毕后响分发器通知继续执行")])])]),_._v(" "),t("p",[_._v("![image-20240515105135955](/Users/feidi/Library/Application Support/typora-user-images/image-20240515105135955.png)")]),_._v(" "),t("p",[_._v("当处理完一个阶段后，等待内核产生下次事件，使得事件分发器调用事件消费者处理事件")]),_._v(" "),t("p",[_._v("这样使进程占用的内存提前释放，提高并发")]),_._v(" "),t("h2",{attrs:{id:"多进程模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多进程模式"}},[_._v("#")]),_._v(" 多进程模式")]),_._v(" "),t("p",[_._v("通常一个master管理进程，多个worker工作进程，1个可选的cache manager进程，1个可选的cache loader进程")]),_._v(" "),t("p",[_._v("多个进程间平等，通过进程通信实现负载均衡")]),_._v(" "),t("h2",{attrs:{id:"框架启动流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#框架启动流程"}},[_._v("#")]),_._v(" 框架启动流程")]),_._v(" "),t("p",[_._v("main里面：")]),_._v(" "),t("ol",[t("li",[_._v("解析命令行处理参数")]),_._v(" "),t("li",[_._v("时间、正则、错误日志、ssl等初始化")]),_._v(" "),t("li",[_._v("如果处在升级中，需要处理父进程传来的环境变量，恢复资源信息")])]),_._v(" "),t("p",[_._v("Ngx_init_cycle()里面:")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("初始化所有容器")]),_._v(" "),t("li",[_._v("生成"),t("strong",[_._v("核心模块")]),_._v("的配置结构（调核心模块的create_conf），http模块实际上并没有自己的create_conf方法")]),_._v(" "),t("li",[_._v("调用ngx_conf_param解析命令行参数")]),_._v(" "),t("li",[_._v("调用ngx_conf_parse解析配置文件，读取nginx.conf配置文件，每读一行，拿key和各个模块用ngx_command_t注册的命令比对，匹配了就会调对应的句柄。这个过程会处理完全部的http的各级配置")]),_._v(" "),t("li",[_._v("初始化"),t("strong",[_._v("核心模块")]),_._v("（调核心模块的init_conf）、对于http模块来说这里也是null")]),_._v(" "),t("li",[_._v("创建目录打开资源等、设置socket句柄柄监听端口")]),_._v(" "),t("li",[_._v("初始化"),t("strong",[_._v("所有模块")]),_._v("（调模块的init_module方法），对于http和http_core这个也是没有的")])]),_._v(" "),t("p",[_._v("main里面：")]),_._v(" "),t("ol",{attrs:{start:"10"}},[t("li",[_._v("根据设置启动master、worker进程，worker进程执行"),t("code",[_._v("ngx_worker_process_cycle")]),_._v("函数")]),_._v(" "),t("li",[_._v("调用所有模块的init_process方法")])]),_._v(" "),t("p",[_._v("其中，ngx_conf_parseh函数对配置的解析：")]),_._v(" "),t("p",[t("strong",[_._v("worker进程的循环：")])]),_._v(" "),t("p",[t("code",[_._v("ngx_worker_process_cycle")]),_._v("函数内会循环"),t("code",[_._v("ngx_process_events_and_timers")]),_._v("，另外四个全局标志位会根据收到的四种信号改变，控制worker的执行")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("全局标志位")]),_._v(" "),t("th",[_._v("信号")]),_._v(" "),t("th",[_._v("意义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ngx_reopen")]),_._v(" "),t("td",[_._v("USR1")]),_._v(" "),t("td",[_._v("用-s reopen重新打开所有文件,用于把当前日志文件转移到其他目录再重新生成新的日志文件")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_quit")]),_._v(" "),t("td",[_._v("QUIT")]),_._v(" "),t("td",[_._v("安全的关闭进程，关闭连接-等待计时器-是否内存池")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_terminate")]),_._v(" "),t("td",[_._v("TERM、INT")]),_._v(" "),t("td",[_._v("强制关闭进程，只释放内存池")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_exiting")]),_._v(" "),t("td",[_._v("？")]),_._v(" "),t("td",[_._v("？")])])])]),_._v(" "),t("p",[t("strong",[_._v("master进程的循环：")])]),_._v(" "),t("p",[_._v("master和worker循环方式不同，master只收到了信号才开始执行一遍循环")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("全局标志位")]),_._v(" "),t("th",[_._v("信号")]),_._v(" "),t("th",[_._v("意义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ngx_reap")]),_._v(" "),t("td",[_._v("CHLD")]),_._v(" "),t("td",[_._v("有子进程意外结束,ngx_reap_children")])]),_._v(" "),t("tr",[t("td",[_._v("Ngx_quit")]),_._v(" "),t("td",[t("strong",[_._v("QUIT")])]),_._v(" "),t("td",[_._v("安全退出,先等待关闭子进程后，删除pid文件，销毁监听，释放内存")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_terminate")]),_._v(" "),t("td",[t("strong",[_._v("TERM、INT")])]),_._v(" "),t("td",[_._v("强制关闭")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_reconfigure")]),_._v(" "),t("td",[_._v("HUP")]),_._v(" "),t("td",[_._v("重读配置文件并使新配置生效")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_restart")]),_._v(" "),t("td",[_._v("无")]),_._v(" "),t("td",[_._v("master进程内部使用的，感觉没啥意义")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_reopen")]),_._v(" "),t("td",[t("strong",[_._v("USR1")])]),_._v(" "),t("td",[_._v("重新打开服务所有文件")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_change_binary")]),_._v(" "),t("td",[_._v("USR2")]),_._v(" "),t("td",[_._v("平滑更新nginx版本")])]),_._v(" "),t("tr",[t("td",[_._v("ngx_noaccept")]),_._v(" "),t("td",[_._v("WINCH")]),_._v(" "),t("td",[_._v("所有子进程不再接收新的连接，相当于对子进程发送QUIT信号量")])])])]),_._v(" "),t("h2",{attrs:{id:"一个基本的模块所需要的数据对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个基本的模块所需要的数据对象"}},[_._v("#")]),_._v(" 一个基本的模块所需要的数据对象")]),_._v(" "),t("h1",{attrs:{id:"框架数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#框架数据结构"}},[_._v("#")]),_._v(" 框架数据结构")]),_._v(" "),t("h2",{attrs:{id:"nginx框架结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx框架结构"}},[_._v("#")]),_._v(" nginx框架结构")]),_._v(" "),t("p",[_._v("一个nginx服务只有一个ngx_cycle_s类型的全局变量，包含配置文件，使用资源等信息")]),_._v(" "),t("h2",{attrs:{id:"nginx的进程管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx的进程管理"}},[_._v("#")]),_._v(" nginx的进程管理")]),_._v(" "),t("p",[_._v("进程的状态改变：")]),_._v(" "),t("p",[_._v("子进程意外退出时，内核发送CHLD信号，nginx的信号处理函数ngx_process_get_status会将sig_reap置1，遍历进程数组修改对应的状态")]),_._v(" "),t("h2",{attrs:{id:"模块数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块数据结构"}},[_._v("#")]),_._v(" 模块数据结构")]),_._v(" "),t("p",[_._v("所有模块的基类")]),_._v(" "),t("p",[_._v("事件模块类型")]),_._v(" "),t("h2",{attrs:{id:"事件数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件数据结构"}},[_._v("#")]),_._v(" 事件数据结构")]),_._v(" "),t("h2",{attrs:{id:"连接对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接对象"}},[_._v("#")]),_._v(" 连接对象")]),_._v(" "),t("p",[_._v("这两个连接对象都只能从连接池中拿到")]),_._v(" "),t("h2",{attrs:{id:"变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[_._v("#")]),_._v(" 变量")]),_._v(" "),t("p",[_._v("同一个请求在模块间的传递或在配置文件里使用模块动态的数据（例如配置里设置的ip）")]),_._v(" "),t("p",[_._v("两种变量定义的方式，一种是在配置文件里用set定义，一种是在模块中定义变量后导出")]),_._v(" "),t("p",[_._v("请求阶段赋值变量，同时保存在数组和hash表里（可选）")]),_._v(" "),t("p",[_._v("初始化流程：")]),_._v(" "),t("ol",[t("li",[_._v("解析http时会调用ngx_http_variables_add_core_vars来将变量添加到全局的hash key链中")]),_._v(" "),t("li",[_._v("解析完http模块后，调用ngx_http_variables_init_vars初始化变量")]),_._v(" "),t("li",[_._v("对每个请求创建一个变量数组")])]),_._v(" "),t("p",[t("strong",[_._v("创建变量：")])]),_._v(" "),t("p",[_._v("调用"),t("code",[_._v("ngx_http_add_variable")]),_._v("创建变量，将变量name添加进全局的hash key表中并初始化域")]),_._v(" "),t("p",[t("strong",[_._v("使用变量：")])]),_._v(" "),t("h1",{attrs:{id:"nginx提供的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx提供的数据结构"}},[_._v("#")]),_._v(" nginx提供的数据结构")]),_._v(" "),t("h2",{attrs:{id:"内存池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存池"}},[_._v("#")]),_._v(" 内存池")]),_._v(" "),t("p",[_._v("针对大块的内存单独申请空间，并提供单独的释放函数")]),_._v(" "),t("p",[_._v("针对小块的内存用内存池复用。")]),_._v(" "),t("p",[_._v("大小块内存的分界是一页内存")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240627112952676.png",alt:"image-20240627112952676"}})]),_._v(" "),t("p",[_._v("pool的分配：")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240627155341509.png",alt:"image-20240627155341509"}})]),_._v(" "),t("p",[_._v("pool销毁：")]),_._v(" "),t("ol",[t("li",[_._v("先调cleanup回调函数")]),_._v(" "),t("li",[_._v("释放大块内存")]),_._v(" "),t("li",[_._v("打印小块内存的使用情况")]),_._v(" "),t("li",[_._v("释放小块内存")])]),_._v(" "),t("p",[_._v("这里的fail标志位控制分配内存的起始块，每次分配小块内存的时候，遍历ngx_pool_t链表找到合适的空间分配，如果多次分配都失败（fail>5），那么这个链表节点不再参与分配，相当于从链表表头忽略了前几个节点")]),_._v(" "),t("h2",{attrs:{id:"散列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[_._v("#")]),_._v(" 散列表")]),_._v(" "),t("p",[_._v("哈希表，通过线性探测再散列的方式解决冲突")]),_._v(" "),t("p",[_._v("存在需要对于"),t("code",[_._v("*.test.com")]),_._v("或者"),t("code",[_._v("www.test.*")]),_._v("这样带有通配符的key查找的情况，因此就需要实现带通配符的散列表查找")]),_._v(" "),t("p",[_._v("nginx是将"),t("code",[_._v("test.com")]),_._v("和"),t("code",[_._v("www.test")]),_._v("单独做为key，放到专门的前缀后缀散列表里面，每次查找先全值匹配，再前缀匹配，再后缀匹配")]),_._v(" "),t("h1",{attrs:{id:"事件处理模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件处理模块"}},[_._v("#")]),_._v(" 事件处理模块")]),_._v(" "),t("p",[_._v("事件主要指网络事件和定时器事件，包括epoll读写、普通定时器事件、expirt实现的读写事件")]),_._v(" "),t("h2",{attrs:{id:"核心模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心模块"}},[_._v("#")]),_._v(" 核心模块")]),_._v(" "),t("p",[_._v("nginx启动时在ngx_cycle_t的read_events/write_events成员中预分配了所有的读写事件")]),_._v(" "),t("p",[_._v("通过"),t("code",[_._v("ngx_event_get_conf(ngx_cycle_t->conf_ctx, 模块名)")]),_._v("来获取对应模块的配置结构")]),_._v(" "),t("p",[_._v("set处理配置信息的方法：")]),_._v(" "),t("ol",[t("li",[_._v("初始化所有事件模块的ctx_index编号")]),_._v(" "),t("li",[_._v("调用所有事件模块的create_conf方法")]),_._v(" "),t("li",[_._v("读取配置文件解析子模块的配置项")]),_._v(" "),t("li",[_._v("调用所有模块的init_conf方法")])]),_._v(" "),t("blockquote",[t("p",[_._v("事件过期的判断：")]),_._v(" "),t("p",[_._v("存在一个场景，顺序处理事件时，事件1关闭了连接归还到连接池，事件2从连接池取得对象和另一个用户建立连接，事件3处理事件1的用户的事件，实际上这个连接已经关闭了，但事件3无法感知")]),_._v(" "),t("p",[_._v("解决，复用指针的最后一位（指针的最后一位一定为0），使用连接对象的指针，从连接池取出对象时改变最后一位的值并记录到自己的instance。使用时通过指针的最后一位和自己记录的instance比较，一样说明没有经过连接池，没有过期\n真的彻底解决了吗？？？如果中间经过了两次取连接池呢")])]),_._v(" "),t("p",[_._v("ngx_command_t中定义了7个命令项，也就是对7个配置项感兴趣：")]),_._v(" "),t("ul",[t("li",[_._v("worker_connections、connections:获取每个worker进程的最大tcp连接数")]),_._v(" "),t("li",[_._v("use: 解析配置确定使用哪个事件处理模块作为事件驱动机制")]),_._v(" "),t("li",[_._v("multi_accept:epoll模式下，调用accpet尽可能多地接收新的连接，将启动事件数据结构里的available字段？")]),_._v(" "),t("li",[_._v("Accept_mutex:是否使用负载均衡器，默认打开。用于确保worker进程接收连接数量多负载均衡。")]),_._v(" "),t("li",[_._v("Accept_mutex_delay:启用accept_mutex负载均衡锁后，延迟accept_mutex_delay毫秒后再试图处理新连接事件")]),_._v(" "),t("li",[_._v("debug_connection：对收到新的连接时打印debug级别的日志")])]),_._v(" "),t("h2",{attrs:{id:"ngx-event-core-module模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ngx-event-core-module模块"}},[_._v("#")]),_._v(" ngx_event_core_module模块")]),_._v(" "),t("p",[_._v("ngx_event_core_module模块和ngx_event_module模块都是在ngx_event.c文件中的")]),_._v(" "),t("p",[_._v("Nginx定义了一系列（目前为9个）运行在不同内核版本上的事件驱动模块，nginx只会启用一个模块")]),_._v(" "),t("p",[_._v("在worker启动前，先调了ngx_event_module_init方法初始化一些变量，启动后在进入循环前，先调用ngx_event_core_module模块的ngx_event_process_init:")]),_._v(" "),t("ol",[t("li",[_._v("初始化定时器和负载均衡器（如果打开了负载均衡，但又只有一个子进程还是会关闭）")]),_._v(" "),t("li",[_._v("初始化use配置里指定的那个事件模块")]),_._v(" "),t("li",[_._v("预分配free_connections连接池对象、ngx_event_t读写事件池")]),_._v(" "),t("li",[_._v("为新连接事件注册accept方法，将监听对象连接的读事件添加到事件驱动模块中")])]),_._v(" "),t("h2",{attrs:{id:"ngx-epoll-module模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ngx-epoll-module模块"}},[_._v("#")]),_._v(" ngx_epoll_module模块")]),_._v(" "),t("p",[_._v("其中只对两个配置项感兴趣，")]),_._v(" "),t("ul",[t("li",[_._v("epoll_events: 一次最多可以返回多少个事件，和预分配多少个结构体")]),_._v(" "),t("li",[_._v("Worker_aio_requests: 如果开启了异步io，初始分配的异步io数")])]),_._v(" "),t("p",[_._v("epoll没有enable和disable，因此是调用add和del借口实现的")]),_._v(" "),t("p",[t("code",[_._v("ngx_epoll_process_events")]),_._v("处理事件流程：")]),_._v(" "),t("h2",{attrs:{id:"定时器事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定时器事件"}},[_._v("#")]),_._v(" 定时器事件")]),_._v(" "),t("p",[_._v("nginx的定时器不依赖内核，每个进程都会单独的管理时间")]),_._v(" "),t("p",[_._v("更新时间的操作全部由ngx_epoll_process_events方法里执行")]),_._v(" "),t("h2",{attrs:{id:"事件驱动架构-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动架构-2"}},[_._v("#")]),_._v(" 事件驱动架构")]),_._v(" "),t("p",[_._v("worker启动后调用ngx_event_core_module模块的ngx_event_process_init，其中将监听事件的连接处理函数"),t("code",[_._v("ngx_event_accept")]),_._v("注册进去，当监听到连接请求时将调用。")]),_._v(" "),t("p",[_._v("监听时涉及到惊群问题和负载均衡问题，解决这个问题离不开post机制，用于将一个事件延后执行。")]),_._v(" "),t("p",[_._v("nginx设计了两个post队列，一个是被触发的监听连接读事件构成的ngx_posted_accept_events队列，一个是普通读写事件构成的ngx_posted_events队列。将epoll_wait产生的事件分发到两个队列，ngx_posted_accept_events队列优先执行")]),_._v(" "),t("h3",{attrs:{id:"建立新的连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建立新的连接"}},[_._v("#")]),_._v(" 建立新的连接")]),_._v(" "),t("p",[t("code",[_._v("ngx_event_accept")]),_._v("流程如下：")]),_._v(" "),t("ol",[t("li",[_._v("调用accept方法建立连接")]),_._v(" "),t("li",[_._v("设置新的负载均衡阔值ngx_accept_disabled")]),_._v(" "),t("li",[_._v("从连接池中获取一个ngx_connection_t对象并初始化")]),_._v(" "),t("li",[_._v("添加到epoll里")]),_._v(" "),t("li",[_._v("调用监听端口上的handler回调方法")]),_._v(" "),t("li",[_._v("如果设置了multi_accept配置项，那么这里将循环去建立下一个连接，即一次性尽量多的建立连接")])]),_._v(" "),t("h3",{attrs:{id:"解决惊群和负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决惊群和负载均衡"}},[_._v("#")]),_._v(" 解决惊群和负载均衡")]),_._v(" "),t("p",[_._v("当一个连接请求进来时，可能同时唤醒多个睡眠的worker进程，但只有一个进程会竞争到锁，其他进程的唤醒是一种浪费。")]),_._v(" "),t("p",[_._v("（部分操作系统可能在底层解决了这个问题）")]),_._v(" "),t("p",[_._v("惊群：")]),_._v(" "),t("p",[_._v("每个worker进程循环时会根据参数决定是否执行"),t("code",[_._v("ngx_trylock_accept_mutex")]),_._v("函数，")]),_._v(" "),t("p",[_._v("当竞争到了这个锁，才能监听端口，即同一时刻只有一个进程在监听端口，没有竞争到锁的进程不再建立新的连接，只处理它已经建立的连接事件")]),_._v(" "),t("p",[_._v("这里的竞争这个锁是用的gcc提供的cas机制")]),_._v(" "),t("p",[_._v("负载均衡：")]),_._v(" "),t("p",[_._v("初始化时，这个变量是个负值，为连接总数的7/8，调用ngx_event_accept函数建立新连接时里面会修改这个值。当其为负数时不会触发负载均衡的操作，为正值时不会处理新连接事件，而是使值-1。")]),_._v(" "),t("p",[_._v("整体流程：")]),_._v(" "),t("p",[_._v("//cpu绑定的方式执行进程，计时器事件采用同步方式好于异步方式？")]),_._v(" "),t("h2",{attrs:{id:"文件的异步io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件的异步io"}},[_._v("#")]),_._v(" 文件的异步io")]),_._v(" "),t("blockquote",[t("p",[_._v("linux内核的异步io一定会走磁盘即使内存里有数据，因此使不使用异步io要看情况")]),_._v(" "),t("p",[_._v("linux内核只能异步读，不能异步写（linux写操作本身就走的缓存延迟写）")]),_._v(" "),t("p",[_._v("《深入理解nginx》p339")])]),_._v(" "),t("h1",{attrs:{id:"http框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http框架"}},[_._v("#")]),_._v(" http框架")]),_._v(" "),t("p",[_._v("http框架由模块ngx_http_modue、ngx_http_core_module\\ngx_http_upstream_module组成")]),_._v(" "),t("p",[_._v("框架主要功能：")]),_._v(" "),t("ul",[t("li",[_._v("解析管理配置文件的配置项")]),_._v(" "),t("li",[_._v("调用事件模块监听端口，处理读写事件")]),_._v(" "),t("li",[_._v("验证发来包的完整性")]),_._v(" "),t("li",[_._v("将请求分发到各个模块处理")]),_._v(" "),t("li",[_._v("提供处理网络io、磁盘io的工具")]),_._v(" "),t("li",[_._v("为http模块提供upstream机制访问第三方服务、subrequest机制实现子模块")])]),_._v(" "),t("h2",{attrs:{id:"限流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[_._v("#")]),_._v(" 限流")]),_._v(" "),t("p",[_._v("Nginx中限制请求发送频率和并发连接数的实现：")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("限制请求发送频率（rate limiting）：")])]),_._v(" "),t("p",[_._v("在权限判断之前做（NGX_HTTP_PREACCESS_PHASE阶段）")]),_._v(" "),t("ul",[t("li",[_._v("使用leaky bucket漏桶算法实现")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("限制并发连接数：")])]),_._v(" "),t("p",[_._v("在连接建立阶段之前实现")]),_._v(" "),t("ul",[t("li",[_._v("使用共享内存记录总体连接数")])])])]),_._v(" "),t("h2",{attrs:{id:"配置项的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置项的管理"}},[_._v("#")]),_._v(" 配置项的管理")]),_._v(" "),t("p",[_._v("http模块会调用create_main_conf、create_srv_conf、create_loc_conf分别生成结构体，之所以这样而不是一个结构体全部包含完，是为了能处理配置里的合并项")]),_._v(" "),t("p",[_._v("在创建main级别的配置项时必须同时创建3个结构体，用于合并之后会解析到的server、location的配置项。每个server必须创建两个结构体，一个自己，一个存储location的配置项")]),_._v(" "),t("p",[_._v("对于这样的配置项实际上会生成7个结构块")]),_._v(" "),t("p",[_._v("ngx_http_conf_ctx_t结构体里main_conf数组的存放各个模块的配置项指针，而这个顺序是按照模块的排序来的，因此main_conf[0]一定是ngx_http_core_module模块的ngx_http_core_main_conf_t结构体，其他配置级别同理")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91//Users/feidi/Documents/typora/computer-science/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240520115827869.png",alt:"image-20240520115827869"}})]),_._v(" "),t("p",[_._v("配置的合并（to be continue）")]),_._v(" "),t("p",[_._v("对于server的检索：采用散列表的数据结构，从而达到较好的查询效率")]),_._v(" "),t("p",[_._v("对于location的检索：采用平衡二叉查找树，不用红黑树是因为location是静态的不会改变，因此使用平衡二叉树能有更好的性能")]),_._v(" "),t("h2",{attrs:{id:"端口结构的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#端口结构的管理"}},[_._v("#")]),_._v(" 端口结构的管理")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240523111820778.png",alt:"image-20240523111820778"}})]),_._v(" "),t("h2",{attrs:{id:"http请求流程的阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http请求流程的阶段"}},[_._v("#")]),_._v(" http请求流程的阶段")]),_._v(" "),t("p",[_._v("11个阶段中，7个阶段里每个阶段都可以增加任意数量的模块进行处理，4个阶段不允许增加第三方模块")]),_._v(" "),t("p",[_._v("11个阶段：")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240827135736430.png",alt:"11个阶段"}})]),_._v(" "),t("p",[_._v("控制阶段的数据结构：")]),_._v(" "),t("p",[_._v("第三方http模块接入各个阶段的方式：")]),_._v(" "),t("p",[_._v("向全局的"),t("code",[_._v("ngx_http_core_main_conf_t")]),_._v("结构体的phases数组中添加"),t("code",[_._v("ngx_http_handler_pt")]),_._v("来实现")]),_._v(" "),t("p",[_._v("NGX_HTTP_CONTENT_PHASE阶段例外，可以按照test例子里的方式接入")]),_._v(" "),t("h2",{attrs:{id:"http框架流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http框架流程"}},[_._v("#")]),_._v(" http框架流程")]),_._v(" "),t("p",[_._v("为什么要有http框架？")]),_._v(" "),t("p",[_._v("事件驱动架构在性能上不错，但开发效率不高，关注的是tcp层面的传输。")]),_._v(" "),t("p",[_._v("作为web服务器，更需要关注业务，因此http模块屏蔽网络事件细节，可以灵活的接入11个阶段处理，关注的是http层的传输。")]),_._v(" "),t("p",[_._v("主要有四部分工作：")]),_._v(" "),t("ul",[t("li",[_._v("集成事件驱动模块，处理读写事件和定时器事件")]),_._v(" "),t("li",[_._v("在不同阶段调度不同http模块")]),_._v(" "),t("li",[_._v("将请求分解为子请求（事件驱动提高了性能但提高了开发难度，因此分解请求降低难度）")]),_._v(" "),t("li",[_._v("提供基本的工具接口，接发包体等")])]),_._v(" "),t("h3",{attrs:{id:"建立连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建立连接"}},[_._v("#")]),_._v(" 建立连接")]),_._v(" "),t("p",[_._v("事件框架把连接建立起来后的最后一步会调用ngx_listening_t里的handler方法，即http模块里的ngx_http_init_connection")]),_._v(" "),t("h3",{attrs:{id:"第一次可读事件的处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一次可读事件的处理"}},[_._v("#")]),_._v(" 第一次可读事件的处理")]),_._v(" "),t("p",[_._v("第一次读事件时走"),t("code",[_._v("ngx_http_wait_request_handler")]),_._v("，以后再有读事件走"),t("code",[_._v("ngx_http_process_request_line")])]),_._v(" "),t("p",[_._v("这是因为nginx第一次连接时不会分配内存，而是延迟到有数据过来时再分配内存初始化请求")]),_._v(" "),t("h3",{attrs:{id:"接收请求行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接收请求行"}},[_._v("#")]),_._v(" 接收请求行")]),_._v(" "),t("p",[_._v("ngx_http_process_request_line方法读取行，但不一定一次能读完，因此这个方法可能多次调用")]),_._v(" "),t("h3",{attrs:{id:"接收http头部"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接收http头部"}},[_._v("#")]),_._v(" 接收http头部")]),_._v(" "),t("p",[_._v("接收较大的头部时依然可能被多次调用")]),_._v(" "),t("h3",{attrs:{id:"处理http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#处理http请求"}},[_._v("#")]),_._v(" 处理http请求")]),_._v(" "),t("p",[_._v("对于异步驱动的http框架来说，处理请求可能分多步进行，第一次都是调"),t("code",[_._v("ngx_http_process_request")]),_._v("，后面都是调回调"),t("code",[_._v("ngx_http_request_handler")])]),_._v(" "),t("p",[_._v("对于第一次的处理")]),_._v(" "),t("p",[_._v("对于非第一次的处理")]),_._v(" "),t("p",[_._v("各个阶段和模块的交互：")]),_._v(" "),t("p",[_._v("NGX_HTTP_POST_READ_PHASE")]),_._v(" "),t("p",[_._v("NGX_HTTP_PREACCESS_PHASE")]),_._v(" "),t("p",[_._v("NGX_HTTP_LOG_PHASE阶段的checker方法：")]),_._v(" "),t("p",[_._v("NGX_HTTP_SERVER_REWRITE_PHASE")]),_._v(" "),t("p",[_._v("NGX_HTTP_REWRITE_PHASE阶段的checker")]),_._v(" "),t("p",[_._v("NGX_HTTP_ACCESS_PHASE")]),_._v(" "),t("p",[_._v("NGX_HTTP_CONTENT_PHASE阶段：")]),_._v(" "),t("p",[_._v("如果希望一个方法应用到所有用户请求，应在ngx_http_module_t接口中的postconfiguration方法中，向ngx_http_core_main_conf_t结构体的phases[NGX_HTTP_CONTENT_PHASE]动态数组中添加ngx_http_handler_pt处理方法。如果只是希望应用到这个location，则注册到ngx_command_t就好")]),_._v(" "),t("blockquote",[t("p",[_._v("如果用第二种方法设置，那么当前阶段只会执行这一个方法，如果用第一种方法，那么当前阶段没有这个限制")]),_._v(" "),t("p",[_._v("如果用了两种方法设置，那么只有第二种方法的会生效")]),_._v(" "),t("p",[_._v("如果用第二种方法设置了多个，那么只会有一个生效")])]),_._v(" "),t("blockquote",[t("p",[_._v("在NGX_HTTP_CONTENT_PHASE阶段后并不会直接调用NGX_HTTP_LOG_PHASE模块的回调，因为NGX_HTTP_LOG_PHASE通常是在整个请求流程结束后才作日志记录，通常是在ngx_http_free_request方法")])]),_._v(" "),t("h3",{attrs:{id:"subrequest与post请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#subrequest与post请求"}},[_._v("#")]),_._v(" subrequest与post请求")]),_._v(" "),t("blockquote",[t("p",[_._v("为什么需要subrequest机制，完全无阻塞的事件驱动机制，涉及读请求（连接、关闭、可读），写请求，定时器三类事件，连接上又可能同时与多个上游服务器有多个tcp连接，处理的事件太多使得复杂度过高。")])]),_._v(" "),t("p",[_._v("http模块中")]),_._v(" "),t("ul",[t("li",[_._v("为一个请求添加新的事件")]),_._v(" "),t("li",[_._v("把已经由定时器、epoll中移除的事件加入其中")])]),_._v(" "),t("p",[_._v("都需要把引用计数+1")]),_._v(" "),t("p",[_._v("subrequest将请求拆分成多个互不相关的子请求，post基于subrequest实现")]),_._v(" "),t("p",[_._v("执行post请求的方法")]),_._v(" "),t("h3",{attrs:{id:"处理包体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#处理包体"}},[_._v("#")]),_._v(" 处理包体")]),_._v(" "),t("p",[_._v("对待包体有接收到缓冲区和丢弃两种方案：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("异步接收到缓存区"),t("code",[_._v("ngx_http_read_client_request_body")]),_._v("方法")])]),_._v(" "),t("li",[t("p",[_._v("丢弃包体（并不是直接丢弃，而是接收后不移动到缓冲区），"),t("code",[_._v("ngx_http_client_body_handler_pt")]),_._v("方法")])])]),_._v(" "),t("p",[_._v("对于用户而言调用ngx_http_read_client_request_body，后面再有这个包体的内容过来时调用的方法是"),t("code",[_._v("ngx_http_read_client_request_body_handler")]),_._v("，这两个方法做的事情都是去套接字上的缓冲区读数据，因此他们的共性部分提取出来为"),t("code",[_._v("ngx_http_do_read_client_request_body")])]),_._v(" "),t("p",[_._v("包体的数据结构：")]),_._v(" "),t("p",[t("strong",[_._v("接收包体：")])]),_._v(" "),t("p",[_._v("第一次数据来的方法：")]),_._v(" "),t("p",[_._v("后面数据来的回调：")]),_._v(" "),t("p",[t("strong",[_._v("放弃接收包体")])]),_._v(" "),t("p",[_._v("其实就是接收包体但不保存，直接丢弃")]),_._v(" "),t("h3",{attrs:{id:"发送http响应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送http响应"}},[_._v("#")]),_._v(" 发送http响应")]),_._v(" "),t("p",[_._v("因为对于http模块来说，大多数情况下发送http响应的时候就是这个请求结束的时候，为了不发送完后还来调关闭请求的回调。nginx的设计是发送响应时必须和结束请求的方法配合使用")]),_._v(" "),t("p",[_._v("这里的发送即过滤模块的流水线式的方式，让每个感兴趣的http模块加入到 "),t("code",[_._v("ngx_http_send_header")]),_._v(",通过每个过滤模块中独有的指针将各个过滤头部的方法连接起来，调ngx_http_send_header时就依次调用了各个过滤模块的方法。")]),_._v(" "),t("p",[_._v("最后一个过滤方法负责发送头部（ngx_http_header_filter_module模块,它的方法为"),t("code",[_._v("ngx_http_header_filter")]),_._v("方法）")]),_._v(" "),t("p",[_._v("如果要发送的响应头大于缓存无法一次发完，ngx_http_request_t中的ngx_chain_t的成员out将保存没有发送完的响应头部，且"),t("code",[_._v("ngx_http_header_filter")]),_._v("方法返回NGX_AGAIN")]),_._v(" "),t("p",[_._v("发送包体的函数也是类似依次调用过滤模块")]),_._v(" "),t("p",[_._v("过滤模块的最后一个模块的方法就是上面提到的ngx_http_write_filter方法")]),_._v(" "),t("h3",{attrs:{id:"结束http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结束http请求"}},[_._v("#")]),_._v(" 结束http请求")]),_._v(" "),t("p",[_._v("事件驱动机制下，一个请求可能被多个事件触发，因此结束请求必须要等到所有事件都结束了。")]),_._v(" "),t("p",[_._v("http将请求分为多种动作，如果http框架提供的方法会导致nginx会再次调度到请求（例如在方法中产生了新事件或重新将已有事件加到epoll或定时器中），那么认为这一步是独立的动作。对于每个http请求都有引用计数，每次派生出动作时+1，结束动作都调ngx_http_finalize_request方法-1。")]),_._v(" "),t("p",[_._v("一、关闭tcp连接函数"),t("code",[_._v("ngx_http_close_connection")]),_._v("：从定时器、epoll、post队列中取出，释放空间到连接池，关闭连接")]),_._v(" "),t("p",[_._v("二、释放ngx_http_request_t数据结构的函数"),t("code",[_._v("ngx_http_free_request")]),_._v("方法：")]),_._v(" "),t("p",[_._v("每一个请求结束都会调用这个方法，一个连接可以涉及多次请求释放")]),_._v(" "),t("ol",[t("li",[_._v("遍历"),t("code",[_._v("ngx_http_cleanup_s")]),_._v("链表，释放资源")]),_._v(" "),t("li",[_._v("调用http11个阶段的最后一个阶段NGX_HTTP_LOG_PHASE记录日志")]),_._v(" "),t("li",[_._v("销毁结构体中的pool内存池")])]),_._v(" "),t("p",[_._v("三、关闭请求"),t("code",[_._v("ngx_http_cloase_request")]),_._v("：")]),_._v(" "),t("p",[_._v("当原始请求引用计数为0并且block为0则依次调用ngx_http_free_request、ngx_http_close_connection")]),_._v(" "),t("p",[_._v("四、"),t("code",[_._v("ngx_http_finalize_connection")]),_._v("方法")]),_._v(" "),t("p",[_._v("用于解决keepalive特性和延迟关闭")]),_._v(" "),t("p",[_._v("如果应用计数为1，判断keep alive标志，即这个连接是否要复用，判断lingering_close标志表示需要延迟关闭（设置定时器实现ngx_http_set_lingering_close），确认关闭时则调用ngx_http_cloase_request方法")]),_._v(" "),t("p",[_._v("五、"),t("code",[_._v("ngx_http_terminate_request")]),_._v("方法")]),_._v(" "),t("p",[_._v("http模块提供的强制关闭请求的方法，直接将引用计数置1，并调用ngx_http_cloase_request方法")]),_._v(" "),t("p",[_._v("六、"),t("code",[_._v("ngx_http_finalize_request")]),_._v("方法")]),_._v(" "),t("h1",{attrs:{id:"http过滤模块-管道过滤器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http过滤模块-管道过滤器模式"}},[_._v("#")]),_._v(" http过滤模块（管道过滤器模式）")]),_._v(" "),t("p",[_._v("所有过滤模块按照configure设定的顺序，过滤模块之间独立。每个过滤模块处理输入的数据，并将输出的数据传递给下一个过滤模块")]),_._v(" "),t("p",[_._v("这带来了更容易维护，增强（旧模块很容易被新模块替代），新的过滤模块可以很方便的加入到过滤系统中（可拓展），可测试性（灵活变动过滤模块来验证功能）")]),_._v(" "),t("p",[_._v("功能上：将在ngx_http_send_header发送包头和ngx_http_output_filter函数发送包体时调用过滤模块，只处理服务器发出去的数据，不处理客户端发来的数据")]),_._v(" "),t("h2",{attrs:{id:"对过滤模块的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对过滤模块的管理"}},[_._v("#")]),_._v(" 对过滤模块的管理")]),_._v(" "),t("p",[_._v("组织上：由链表串连各个过滤模块，每个元素是一个独立的c源码，其中通过两个static静态指针指向下一个文件中的过滤方法。实质上链表串联是各个过滤模块处理的方法")]),_._v(" "),t("p",[_._v("http框架中两个指针指向链表的第一个元素：")]),_._v(" "),t("p",[_._v("http模块中对过滤模块处理包头和包体的方法做了定义")]),_._v(" "),t("p",[_._v("初始化串联各个过滤模块的方法：")]),_._v(" "),t("p",[_._v("每个模块都有两个指针指向下个过滤模块处理包体和包头的方法，在过滤模块初始化时，每个模块将自己插入到链表的表头")]),_._v(" "),t("p",[_._v("即过滤模块在ngx_module.c的顺序越靠后，越先执行，可以在编译前手动修改这个.c来改变顺序")]),_._v(" "),t("p",[_._v("整体调用流程，当调用发送函数发送包头时，从链表的第一个函数开始调用，发送包体函数类似")]),_._v(" "),t("h2",{attrs:{id:"官方提供的过滤模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#官方提供的过滤模块"}},[_._v("#")]),_._v(" 官方提供的过滤模块")]),_._v(" "),t("p",[_._v("官方的过滤模块的顺序被写死在sh脚本内，第三方过滤模块按指定规则加入，可以修改ngx_module.c来改变顺序")]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"image-20240521155726872.png",alt:"image-20240521155726872"}}),_._v(" "),t("h2",{attrs:{id:"编写过滤模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写过滤模块"}},[_._v("#")]),_._v(" 编写过滤模块")]),_._v(" "),t("p",[_._v("config与http模块基本一样，修改类型为HTTP_FILTER_MODULES就行")]),_._v(" "),t("p",[_._v("模块加入，修改configure是一样的。定义过滤模块也是一样的，type依然是NGX_HTTP_MODULE")]),_._v(" "),t("p",[_._v("实现初始化方法，通常写在proconfiguration一栏")]),_._v(" "),t("h1",{attrs:{id:"nginx提供的通信方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx提供的通信方法"}},[_._v("#")]),_._v(" nginx提供的通信方法")]),_._v(" "),t("p",[_._v("消息传递：共享内存、套接字、信号")]),_._v(" "),t("p",[_._v("进程同步：原子操作、信号量、文件锁")]),_._v(" "),t("h2",{attrs:{id:"共享内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),t("h1",{attrs:{id:"日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[_._v("#")]),_._v(" 日志")]),_._v(" "),t("h2",{attrs:{id:"错误日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#错误日志"}},[_._v("#")]),_._v(" 错误日志")]),_._v(" "),t("p",[t("strong",[_._v("level参数：")])]),_._v(" "),t("p",[_._v("error宏里，0为不将日志写入文件，而是直接输出屏幕，8为最低debug级别，记录日志时大于等于log参数设置的日志级别的日志会被记录，其他的会被忽略")]),_._v(" "),t("p",[_._v("debug宏里，均为8的debug级别，level表示日志的类型")]),_._v(" "),t("p",[t("strong",[_._v("log参数：")])]),_._v(" "),t("p",[_._v("通常直接调用http的log结构，不需要关注这个")]),_._v(" "),t("p",[t("strong",[_._v("err：")])]),_._v(" "),t("p",[_._v("错误码")]),_._v(" "),t("p",[t("strong",[_._v("fmt参数：")])]),_._v(" "),t("p",[_._v("可变参数，在printf的基础上增加了一些转换格式")]),_._v(" "),t("h1",{attrs:{id:"上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上下文"}},[_._v("#")]),_._v(" 上下文")]),_._v(" "),t("p",[_._v("http框架为每个http请求提供了对每个http模块的独立的上下文结构体")]),_._v(" "),t("h1",{attrs:{id:"访问第三方服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问第三方服务"}},[_._v("#")]),_._v(" 访问第三方服务")]),_._v(" "),t("p",[_._v("nginx提供了两种全异步的方式来和第三方服务通信，upstream和subrequest方式")]),_._v(" "),t("p",[_._v("upstream首要功能是穿透，当他原封不动的转发第三方的回复时有很好的表现，http框架提供")]),_._v(" "),t("p",[_._v("subrequest是从属请求，nginx取得第三方服务后再决定如何处理客户端的请求，子请求和原始请求可以并发处理")]),_._v(" "),t("h2",{attrs:{id:"upstream方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#upstream方式"}},[_._v("#")]),_._v(" upstream方式")]),_._v(" "),t("p",[_._v("upstream，在完整接收http请求的头部后就和上游服务器建立连接，而不是接收完完整的消息才建立连接")]),_._v(" "),t("p",[_._v("提供8个回调，在请求的结构体中b包含upstream的指针，")]),_._v(" "),t("ul",[t("li",[_._v("创建upstream")]),_._v(" "),t("li",[_._v("使用配置文件里指定的上游服务器地址，或者从请求的URL里动态获取上游服务器地址")]),_._v(" "),t("li",[_._v("调用ngx_http_upstream_init方法启动upstream")]),_._v(" "),t("li",[_._v("在执行的各个阶段会回调他的8个方法")])]),_._v(" "),t("p",[_._v("upstream提供了3种处理上游服务器包体的方式：")]),_._v(" "),t("ul",[t("li",[_._v("交由HTTP模块使用input_filter回调方法直接处理包体")]),_._v(" "),t("li",[_._v("以固定缓冲区转发包体")]),_._v(" "),t("li",[_._v("多个缓冲加磁盘文件的方式转发包体")])]),_._v(" "),t("p",[_._v("启动upstream机制")]),_._v(" "),t("p",[t("img",{attrs:{src:"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20240603140646577.png",alt:"image-20240603140646577"}})])])}),[],!1,null,null,null);t.default=a.exports}}]);