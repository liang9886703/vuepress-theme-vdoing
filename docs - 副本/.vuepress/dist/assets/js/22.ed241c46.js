(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{391:function(v,t,e){"use strict";e.r(t);var _=e(7),a=Object(_.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"环境搭建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环境搭建"}},[v._v("#")]),v._v(" 环境搭建")]),v._v(" "),t("h2",{attrs:{id:"本地环境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地环境"}},[v._v("#")]),v._v(" 本地环境")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/cxd4321/p/17862691.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("nvm安装和配置node版本"),t("OutboundLink")],1)]),v._v(" "),t("p",[v._v("nvm是node.js的版本管理工具，可以同时按照不同nodejs的版本并在不同项目中切换")]),v._v(" "),t("p",[v._v("node.js是服务端的 JavaScript 运行时环境")]),v._v(" "),t("p",[v._v("npm是node.js自带的包管理工具，用于安装相关依赖工具，例如vue、react等")]),v._v(" "),t("p",[t("code",[v._v("npm install vue")])]),v._v(" "),t("p",[v._v("create-vue是vue的自动化工具，可以快速构建vue项目，基于vite。可以代替webpack这类的前端资源打包加载工具")]),v._v(" "),t("p",[v._v("从实现上来说，webpack是对项目资源生成关系依赖图，遍历查看是否有更新并显示到html上，因此生效较慢。vite是通知机制")]),v._v(" "),t("p",[v._v("ES Module是js的官方模块化标准")]),v._v(" "),t("p",[v._v("vue项目结构")]),v._v(" "),t("p",[v._v("编译后端静态文件结构")]),v._v(" "),t("p",[t("img",{attrs:{src:"/%E5%89%8D%E7%AB%AF/image-6.png",alt:"alt text"}})]),v._v(" "),t("p",[v._v("assets内是静态文件，index.html是入口")]),v._v(" "),t("p",[v._v("需要修改index.html中的css、js连接路径")]),v._v(" "),t("p",[t("img",{attrs:{src:"/%E5%89%8D%E7%AB%AF/image-7.png",alt:"alt text"}})]),v._v(" "),t("h2",{attrs:{id:"cdn导入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cdn导入"}},[v._v("#")]),v._v(" CDN导入")]),v._v(" "),t("p",[v._v("使用全局构建版本，这样所有的api都会以属性的形式暴露在全局vue对象上")]),v._v(" "),t("p",[t("code",[v._v('<script src="https://unpkg.com/vue@3/dist/vue.global.js"><\/script>')])]),v._v(" "),t("p",[v._v("无法使用单文件组件 (SFC) 语法")]),v._v(" "),t("p",[v._v("也可以使用es模块构建")]),v._v(" "),t("p",[t("code",[v._v("import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'")])]),v._v(" "),t("p",[v._v("或者")]),v._v(" "),t("h2",{attrs:{id:"一个基本的vue应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个基本的vue应用"}},[v._v("#")]),v._v(" 一个基本的vue应用")]),v._v(" "),t("p",[v._v("当在本地构建的vue项目中，为了导入vue的组件，"),t("code",[v._v("import { ref,createApp} from 'vue';")]),v._v("，")]),v._v(" "),t("p",[v._v("导入的内容可以理解成是一个js对象，vue组件位于node_modules文件中")]),v._v(" "),t("p",[t("strong",[t("code",[v._v("createApp")]),v._v("创建一个vue实例:")])]),v._v(" "),t("p",[v._v("起到对实例做全局配置，包括注册插件、指令和配置等，通过在一个页面中创建多个vue应用，使用不同的配置和全局资源来开发不同页面元素")]),v._v(" "),t("p",[v._v("应用的配置包括配置错误处理")]),v._v(" "),t("p",[v._v("应用的资源注册："),t("code",[v._v("app.component('TodoDeleteButton', TodoDeleteButton)")]),v._v("。比起import的方式导入到当前组件使用，component的方式能对参与这个应用的全部组件生效")]),v._v(" "),t("p",[t("strong",[t("code",[v._v("mount")]),v._v("根组件实例挂载:")])]),v._v(" "),t("p",[v._v("通过mount来将app应用实例生成一个根组件实例挂载到 DOM 元素，（必须要对应用配置完成后），mount()里的参数为DOM元素或css选择器，根元素的内容将渲染在容器元素中")]),v._v(" "),t("p",[v._v("一个根组件实例对应一个应用实例，管理整个组件树的渲染")]),v._v(" "),t("p",[t("strong",[v._v("根组件实例的一些操作")])]),v._v(" "),t("p",[v._v("组件实例对象里的$data对象包含了在data（）定义的数据，"),t("code",[v._v("vm.$data.count")]),v._v("，或直接"),t("code",[v._v("vm.count")])]),v._v(" "),t("p",[v._v("vm.increment()，包含了methods中定义的方法")]),v._v(" "),t("p",[v._v("API风格有组合和选项式API，下面两个例子中分别使用")]),v._v(" "),t("h3",{attrs:{id:"单文件html写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单文件html写法"}},[v._v("#")]),v._v(" 单文件html写法")]),v._v(" "),t("p",[v._v("选项式API，其定义了一些vue属性")]),v._v(" "),t("h3",{attrs:{id:"单文件组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单文件组件"}},[v._v("#")]),v._v(" 单文件组件")]),v._v(" "),t("p",[v._v("组合式风格有两种写法")]),v._v(" "),t("p",[t("code",[v._v("<script setup><\/script>")])]),v._v(" "),t("p",[v._v("这个例子用组合式风格，实现同上一个例子同样的功能")]),v._v(" "),t("p",[v._v("结合单文件组件写法，单文件组件以.vue后缀，允许将HTML、js、css代码放到一个文件中")]),v._v(" "),t("p",[v._v("注意需要使用"),t("code",[v._v('<script type="module">')]),v._v("才能正确使用import关键字")]),v._v(" "),t("h1",{attrs:{id:"语法基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法基础"}},[v._v("#")]),v._v(" 语法基础")]),v._v(" "),t("h2",{attrs:{id:"模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板"}},[v._v("#")]),v._v(" 模板")]),v._v(" "),t("p",[v._v(".vue文件将html+css+js同时显示，其中html的内容以"),t("code",[v._v("<template>")]),v._v("标签包裹，")]),v._v(" "),t("p",[v._v("如果一个标签元素同时有主html设置的内容，vue又通过mount挂载了：")]),v._v(" "),t("ul",[t("li",[v._v("优先使用主html本身就写好了的内容")]),v._v(" "),t("li",[v._v("主HTML没有设置内容，才会被vue挂载显示模板内容")]),v._v(" "),t("li",[v._v("如果vue挂载的组件没有模板内容，则使用默认的innerHTML渲染")])]),v._v(" "),t("p",[v._v("被vue挂载了的对象可以被vue语法修饰，")]),v._v(" "),t("p",[v._v("文本差值和指令两种方式中，都支持嵌套单一的***js表达式*** (可以被放到return后面的被称为js表达式)，也支持***调用组件暴露的方法***")]),v._v(" "),t("blockquote",[t("p",[v._v("注意每次刷新组件的时候都会重新调用方法渲染，因此调用的方法应当是可重入的\n模板中的表达式只能访问到组件里暴露出来的对象列表(例如Date())，其他全局对象，例如window属性可以在app.config.globalProperties对象加上后，供vue表达式使用\n例如  data() {return {globalValue: window.globalValue // 显式引入};}")])]),v._v(" "),t("p",[t("strong",[v._v("文本插值")]),v._v("，"),t("code",[v._v("{{}}")]),v._v("表示将模块里用data定义的数据显示")]),v._v(" "),t("p",[t("strong",[v._v("指令")]),v._v("，前缀"),t("code",[v._v("v-")]),v._v("的特殊属性")]),v._v(" "),t("h2",{attrs:{id:"指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[v._v("#")]),v._v(" 指令")]),v._v(" "),t("p",[t("img",{attrs:{src:"/%E5%89%8D%E7%AB%AF/image-8.png",alt:"完整的指令语法"}})]),v._v(" "),t("h3",{attrs:{id:"v-html-绑定原始html"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-html-绑定原始html"}},[v._v("#")]),v._v(" "),t("code",[v._v("v-html=")]),v._v(": 绑定"),t("strong",[v._v("原始HTML")])]),v._v(" "),t("p",[t("code",[v._v('<span v-html="rawHtml"></span>')]),v._v(",直接输入html标签内容，但这个方法不安全，会有xss漏洞问题")]),v._v(" "),t("h3",{attrs:{id:"v-bind-属性或-属性-添加属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-bind-属性或-属性-添加属性"}},[v._v("#")]),v._v(" "),t("code",[v._v("v-bind:属性")]),v._v("或"),t("code",[v._v(":属性")]),v._v(" 添加属性")]),v._v(" "),t("p",[t("code",[v._v('<a v-bind:href="url">Link</a>')]),v._v(" 简写为"),t("code",[v._v('<a :href="url">Link</a>')])]),v._v(" "),t("p",[v._v("当属性名和绑定的js对象名称相同，也可以"),t("code",[v._v("<div :id></div>")]),v._v(",等同于"),t("code",[v._v('id="id"')])]),v._v(" "),t("p",[v._v("当需要绑定多个值时，不需要"),t("code",[v._v("：")]),v._v(",")]),v._v(" "),t("h3",{attrs:{id:"条件渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染"}},[v._v("#")]),v._v(" 条件渲染：")]),v._v(" "),t("p",[v._v("条件渲染同样适用于整个"),t("code",[v._v("<template>")]),v._v("对象")]),v._v(" "),t("p",[v._v("v-show动态显示或隐藏元素："),t("code",[v._v('<h1 v-show="ok">Hello!</h1>')]),v._v("。不支持在template上使用")]),v._v(" "),t("p",[v._v("v-show是先渲染再切换display属性的，v-if是更局条件决定是否渲染。因此，如果需要频繁切换使用v-show，否则v-if")]),v._v(" "),t("h3",{attrs:{id:"列表渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#列表渲染"}},[v._v("#")]),v._v(" 列表渲染：")]),v._v(" "),t("p",[v._v("v-for和v-if通常不建议同时使用，两者会有优先级问题")]),v._v(" "),t("p",[v._v("共有三个参数"),t("code",[v._v('<li v-for="(value, key, index) in object"> </li>')]),v._v("。key表示属性名，index表索引")]),v._v(" "),t("p",[v._v("循环指定次数")]),v._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),v._v("li")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("v-for")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[v._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')]),v._v("n in 10"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("{{ n }}"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("</")]),v._v("li")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("和v-if一样可以用于template")]),v._v(" "),t("p",[v._v("key是v-for的一个特殊属性，可以用于跟踪每个遍历的对象，应该绑定一个基础类型而不是对象")]),v._v(" "),t("p",[v._v("v-for按照就地更新原则，当数据改变时，不会移动DOM元素，而是重新渲染，因此用key能跟踪每个节点")]),v._v(" "),t("p",[v._v("在组件上使用v-for时，并不会自动将数据传递给组件，因此需要手动添加")]),v._v(" "),t("h3",{attrs:{id:"双向数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定"}},[v._v("#")]),v._v(" 双向数据绑定:")]),v._v(" "),t("p",[v._v("对于一些常用标签，v-model自动对数据做绑定")]),v._v(" "),t("blockquote",[t("p",[v._v("对于用输入法的键入方式，v-model不会在拼写阶段触发更新，如果需要拼写阶段触发更新需要用input")])]),v._v(" "),t("p",[v._v("和选框结合，能自动记录删除更新哪些框被选中了。复选框记录多个，单选框记录一个")]),v._v(" "),t("p",[v._v("当选中时设置自定义的数据，true-value和false-value只能和v-model使用")]),v._v(" "),t("p",[v._v("一些修饰v-model属性的修饰符：")]),v._v(" "),t("ul",[t("li",[v._v(".lazy： 默认每次输入后更新，添加lazy表明每次change事件后更新")]),v._v(" "),t("li",[v._v(".trim：自动去除用户输入中的两段的空格")])]),v._v(" "),t("h3",{attrs:{id:"事件监听器。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件监听器。"}},[v._v("#")]),v._v(" 事件监听器。")]),v._v(" "),t("p",[t("code",[v._v('<button v-on:click="doSomething">Click me</button>')]),v._v("\n简写："),t("code",[v._v('<button @click="doSomething">Click me</button>')])]),v._v(" "),t("p",[v._v("可以使用内联函数使得事件绑定更灵活")]),v._v(" "),t("p",[v._v("对于事件的操作，可以在函数内完成，但为了在方法内集中处理数据而不是DOM，因此vue提供了事件修饰符,支持链式表达")]),v._v(" "),t("ul",[t("li",[v._v(".stop")]),v._v(" "),t("li",[v._v(".prevent")]),v._v(" "),t("li",[v._v(".self")]),v._v(" "),t("li",[v._v(".capture")]),v._v(" "),t("li",[v._v(".once")]),v._v(" "),t("li",[v._v(".passive")])]),v._v(" "),t("blockquote",[t("p",[v._v("@click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。")])]),v._v(" "),t("p",[v._v("鼠标按键修饰符")]),v._v(" "),t("ul",[t("li",[v._v(".left")]),v._v(" "),t("li",[v._v(".right")]),v._v(" "),t("li",[v._v(".middle")])]),v._v(" "),t("p",[v._v("按键别名: ……")]),v._v(" "),t("h3",{attrs:{id:"动态参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态参数"}},[v._v("#")]),v._v(" 动态参数")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v('<a v-bind:[attributeName]="url"> ... </a>\n')])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("在data中定义了attributeName属性的值后，查看attributeName的值并在这里设置。")]),v._v(" "),t("p",[v._v("例如"),t("code",[v._v('<a @[eventName]="doSomething"> ... </a>')]),v._v("，可以实现根据情况绑定一个函数在不同事件上")]),v._v(" "),t("p",[v._v("动态参数应该为字符串或NULL，其他类型报错。attributeName名称将会被浏览器转为小写，因此避免大写")]),v._v(" "),t("h3",{attrs:{id:"修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[v._v("#")]),v._v(" 修饰符")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v('<form @submit.prevent="onSubmit">...</form>\n')])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("用于表明指令以特殊的方式被绑定")]),v._v(" "),t("h2",{attrs:{id:"响应式基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式基础"}},[v._v("#")]),v._v(" 响应式基础")]),v._v(" "),t("p",[v._v("在vue中直接定义的变量不能暴露给template使用，定义响应式的数据使得当数据发生改变时，vue能修改视图重新渲染")]),v._v(" "),t("h3",{attrs:{id:"ref方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref方法"}},[v._v("#")]),v._v(" ref方法")]),v._v(" "),t("p",[v._v("使用ref("),t("code",[v._v("参数")]),v._v(")函数来返回一个类似如下的引用对象，从而为vue实现当数据修改时重新刷新视图的能力")]),v._v(" "),t("p",[v._v("在js中需要用.value来访问值，在template中不需要通过.value。")]),v._v(" "),t("p",[v._v("一个使用ref的例子：")]),v._v(" "),t("p",[v._v("使用setup属性可以不用手动暴露方法和属性")]),v._v(" "),t("p",[v._v("DOM将在下一次的tick中更新数据的修改，如果要在修改后再执行些工作，可以使用nextTick()")]),v._v(" "),t("h3",{attrs:{id:"reactive方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactive方法"}},[v._v("#")]),v._v(" reactive方法")]),v._v(" "),t("p",[v._v("比起ref，reactive返回的是一个proxy对象，对其原始对象的修改不会触发更新，而ref会（因此可以修改原始对象，再要提交的时候修改proxy对象来控制更新的时间，但最佳实践是只操作proxy对象）")]),v._v(" "),t("p",[v._v("对proxy对象调reactive方法不会新生成一个proxy对象，而是返回自己")]),v._v(" "),t("p",[v._v("当ref的值是一个对象时，内部也是调reactive的")]),v._v(" "),t("p",[v._v("reactive只能用于对象类型，不能用于原始内型")]),v._v(" "),t("p",[v._v("在模板渲染中，只有顶级的ref属性才会被解包")]),v._v(" "),t("blockquote",[t("p",[v._v("解构指从对象中提取属性")])]),v._v(" "),t("h3",{attrs:{id:"响应式数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式数组"}},[v._v("#")]),v._v(" 响应式数组")]),v._v(" "),t("p",[v._v("对响应数组提供了一些操作使得vue能监听到变化")]),v._v(" "),t("ul",[t("li",[v._v("push()")]),v._v(" "),t("li",[v._v("pop()")]),v._v(" "),t("li",[v._v("shift()")]),v._v(" "),t("li",[v._v("unshift()")]),v._v(" "),t("li",[v._v("splice()")]),v._v(" "),t("li",[v._v("sort()")]),v._v(" "),t("li",[v._v("reverse()")])]),v._v(" "),t("p",[v._v("下面的方法能对数组做些计算返回新的结果")]),v._v(" "),t("ul",[t("li",[v._v("filter")]),v._v(" "),t("li",[v._v("concat")]),v._v(" "),t("li",[v._v("slice")])]),v._v(" "),t("h2",{attrs:{id:"计算属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[v._v("#")]),v._v(" 计算属性")]),v._v(" "),t("p",[t("code",[v._v("computed(getter方法，setter方法)")]),v._v("函数能传入一个getter函数，返回一个ref计算属性。比起使用函数来实现这个功能，计算属性只会在这个值发生改变时才触发更新，函数只要有改变都会重新执行，可以有更好的性能。setter方法提供一个修改属性的方式")]),v._v(" "),t("p",[v._v("其中getter方法和setter方法时可以有参数的")]),v._v(" "),t("h2",{attrs:{id:"class绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class绑定"}},[v._v("#")]),v._v(" class绑定")]),v._v(" "),t("p",[v._v("可以用v-bind绑定，vue提供了特俗的功能增强")]),v._v(" "),t("h2",{attrs:{id:"style绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#style绑定"}},[v._v("#")]),v._v(" style绑定")]),v._v(" "),t("h2",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[v._v("#")]),v._v(" 生命周期")]),v._v(" "),t("ul",[t("li",[v._v("onMounted() 组件完成初始渲染并创建 DOM 节点后运行传入的回调函数")]),v._v(" "),t("li",[v._v("onUpdated")]),v._v(" "),t("li",[v._v("onUnmounted")])]),v._v(" "),t("p",[t("img",{attrs:{src:"/%E5%89%8D%E7%AB%AF/image-9.png",alt:"alt text"}})]),v._v(" "),t("h2",{attrs:{id:"侦听器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#侦听器"}},[v._v("#")]),v._v(" 侦听器")]),v._v(" "),t("p",[v._v("使用watch能注册一个ref对象改变时触发的回调函数。侦听器尽量用同步的方式创建")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("watch(监听对象，回调函数,可选参数)\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("监听对象可以是响应式对象，getter函数，计算属性")]),v._v(" "),t("p",[v._v("可以同时监听多个响应式属性，只要其中有一个改变就会触发回调")]),v._v(" "),t("p",[v._v("可选参数包括")]),v._v(" "),t("p",[v._v("组合式API")]),v._v(" "),t("p",[t("strong",[v._v("副作用清理")])]),v._v(" "),t("p",[v._v("当回调函数执行副作用时，当前监听的对象又发生改变了，此时希望当前的回调函数结束，onWatcherCleanup函数能监听这种状态")]),v._v(" "),t("p",[v._v("第一种方式：")]),v._v(" "),t("p",[v._v("第二种方式：")]),v._v(" "),t("h2",{attrs:{id:"模板引用ref-一种指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板引用ref-一种指令"}},[v._v("#")]),v._v(" 模板引用ref ，一种指令")]),v._v(" "),t("p",[v._v("通过"),t("code",[v._v("useTemplateRef")]),v._v("函数和"),t("code",[v._v(":ref属性")]),v._v("能直接操作DOM对象")]),v._v(" "),t("p",[v._v("HTTP中"),t("code",[v._v(":ref属性")]),v._v("也可以直接绑定函数")]),v._v(" "),t("blockquote",[t("p",[v._v("v-model+watch更注重观测数据的变化并做相应的计算处理记录。:ref更关注DOM对象的改变，做动态挂载渲染等")])]),v._v(" "),t("p",[v._v("组件中也可以使用"),t("code",[v._v(":ref")]),v._v("语法，如果是选项式 API或没有使用"),t("code",[v._v("<script setup>")]),v._v("，父组件对子组件有完全的访问权。而使用了"),t("code",[v._v("<script setup>")]),v._v("的组件默认私有的，可以通过"),t("code",[v._v("defineExpose")]),v._v("宏显示暴露")]),v._v(" "),t("h2",{attrs:{id:"组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[v._v("#")]),v._v(" 组件")]),v._v(" "),t("p",[v._v("Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC")]),v._v(" "),t("p",[v._v("通过"),t("code",[v._v("<script setup>")]),v._v("，导入的组件都在模板中直接可用。")]),v._v(" "),t("p",[v._v("每使用一个组件都是创建一个实例")]),v._v(" "),t("h3",{attrs:{id:"父组件向子组件传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#父组件向子组件传递"}},[v._v("#")]),v._v(" 父组件向子组件传递")]),v._v(" "),t("p",[v._v("如果要向组件内传递一些东西，那么需要经过"),t("code",[v._v("props")]),v._v("属性，子组件通过"),t("code",[v._v("defineProps")]),v._v("宏来表明这是一个props属性，由父组件传入")]),v._v(" "),t("p",[v._v("一个博客实例")]),v._v(" "),t("p",[v._v("如果子组件定义了但是父组件没有传入，那么并不会报错，而是为null值")]),v._v(" "),t("h3",{attrs:{id:"子组件向父组件传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子组件向父组件传递"}},[v._v("#")]),v._v(" 子组件向父组件传递")]),v._v(" "),t("p",[v._v("子组件通过"),t("code",[v._v("defineEmits(['enlarge-text'])")]),v._v("声明一个自定义事件，通过"),t("code",[v._v("$emit('enlarge-text', 'some txt')")]),v._v("来触发这个自定义事件")]),v._v(" "),t("p",[v._v("父组件通过事件监听的方式来感知并处理"),t("code",[v._v('@enlarge-text="postFontSize += 0.1"')])]),v._v(" "),t("p",[v._v("或者传入一个回调函数，第一个参数为子组件传出来的消息"),t("code",[v._v('@enlarge-text="（msg）=>{console.log(msg)}"')])]),v._v(" "),t("p",[v._v("一个实例，子组件的按钮能控制父组件设置所有子组件的字体大小")]),v._v(" "),t("h3",{attrs:{id:"通过插槽传递"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过插槽传递"}},[v._v("#")]),v._v(" 通过插槽传递")]),v._v(" "),t("p",[v._v("父组件传入的内容自动渲染在子组件的指定部分")]),v._v(" "),t("ul",[t("li",[v._v("默认插槽：未指定名称的内容会进入 "),v._t("default"),v._v("。")],2),v._v(" "),t("li",[v._v("具名插槽：通过 name 属性或 v-slot:name 指定内容插入位置。")]),v._v(" "),t("li",[v._v("作用域插槽：动态传递数据给插槽，增强插槽的灵活性。")])]),v._v(" "),t("h3",{attrs:{id:"动态组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态组件"}},[v._v("#")]),v._v(" 动态组件")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v('<component :is="tabs[currentTab]"></component>\n')])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("tabs是一个自定义的组件数组对象，"),t("code",[v._v("tabs[currentTab]")]),v._v("（可以是组件对象，或组件名字）确定一个组件传递给"),t("code",[v._v(":is")]),v._v("渲染")]),v._v(" "),t("p",[v._v("组件被切换时将触发组件卸载，可以用"),t("code",[v._v("<KeepAlive>")]),v._v(" 组件强制被切换掉的组件仍然保持“存活”的状态")])])}),[],!1,null,null,null);t.default=a.exports}}]);