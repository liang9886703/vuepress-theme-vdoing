(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{415:function(a,t,v){"use strict";v.r(t);var _=v(7),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"卷积核"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#卷积核"}},[a._v("#")]),a._v(" 卷积核")]),a._v(" "),t("h2",{attrs:{id:"高斯卷积"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高斯卷积"}},[a._v("#")]),a._v(" 高斯卷积")]),a._v(" "),t("p",[a._v("高斯核总值的和为1，分布满足正态分布")]),a._v(" "),t("p",[a._v("能消除高斯噪声")]),a._v(" "),t("h2",{attrs:{id:"中值滤波器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中值滤波器"}},[a._v("#")]),a._v(" 中值滤波器")]),a._v(" "),t("p",[a._v("能处理噪声")]),a._v(" "),t("h1",{attrs:{id:"边缘检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#边缘检测"}},[a._v("#")]),a._v(" 边缘检测")]),a._v(" "),t("p",[a._v("canny边缘检测")]),a._v(" "),t("ul",[t("li",[a._v("用高斯函数对图像做滤波处理")]),a._v(" "),t("li",[a._v("计算梯度幅值和方向")]),a._v(" "),t("li",[a._v("对每个点做非最大抑制：得到边缘清晰的图像")]),a._v(" "),t("li",[a._v("从强边开始跟进弱边：解决边缘出现断断续续的情况")])]),a._v(" "),t("h1",{attrs:{id:"特征点提取"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特征点提取"}},[a._v("#")]),a._v(" 特征点提取")]),a._v(" "),t("h2",{attrs:{id:"角点检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#角点检测"}},[a._v("#")]),a._v(" 角点检测")]),a._v(" "),t("p",[a._v("可以找到局部最大点")]),a._v(" "),t("h2",{attrs:{id:"尺度选择特性sift"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#尺度选择特性sift"}},[a._v("#")]),a._v(" 尺度选择特性SIFT")]),a._v(" "),t("h2",{attrs:{id:"dog高斯差分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dog高斯差分"}},[a._v("#")]),a._v(" DOG高斯差分")]),a._v(" "),t("ul",[t("li",[a._v("通过平滑将图像分成多组，每个图片尺寸一样，平滑程度不同")]),a._v(" "),t("li",[a._v("生成DOG金字塔：对相邻的高斯尺度空间图像相减，得到DOG的响应值图片")]),a._v(" "),t("li",[a._v("空间极值点检测：相邻图片3*3的区域内27个像素点的最大值保留")]),a._v(" "),t("li",[a._v("非最大抑制：去除阔值")]),a._v(" "),t("li",[a._v("稳定关键点的方向信息匹配：统计监测点16*16窗口的方向出现次数，得到主方向和辅方向")]),a._v(" "),t("li",[a._v("关键点描述：精简只剩8个辅助方向，作为每个关键点描述符")])]),a._v(" "),t("h2",{attrs:{id:"特征点匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特征点匹配"}},[a._v("#")]),a._v(" 特征点匹配")]),a._v(" "),t("ul",[t("li",[a._v("暴力匹配：最小距离法")]),a._v(" "),t("li",[a._v("暴力匹配：距离阔值法")]),a._v(" "),t("li",[a._v("交叉匹配：一次匹配后，反过来用匹配到的点去匹配，如果仍然能匹配到，则保留")])]),a._v(" "),t("h1",{attrs:{id:"场景的类别识别-词袋向量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景的类别识别-词袋向量"}},[a._v("#")]),a._v(" 场景的类别识别-词袋向量")]),a._v(" "),t("ol",[t("li",[a._v("提取特征：SIFT方法提取图片的所有特征点")]),a._v(" "),t("li",[a._v("学习可视化词汇：用聚类进行分类")]),a._v(" "),t("li",[a._v("构建视觉词典：")]),a._v(" "),t("li",[a._v("用视觉词汇的频率来表示图像：")])]),a._v(" "),t("h1",{attrs:{id:"受监督的机器学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#受监督的机器学习"}},[a._v("#")]),a._v(" 受监督的机器学习")]),a._v(" "),t("h2",{attrs:{id:"knn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#knn"}},[a._v("#")]),a._v(" KNN：")]),a._v(" "),t("p",[a._v("是一种分类算法，懒惰学习，")]),a._v(" "),t("p",[a._v("数据事先分好了类，对于新加入的一个数据，找到离他最近的k个值，这个数据属于k个值里所属分类比例最大的那个类")]),a._v(" "),t("h2",{attrs:{id:"支持向量机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持向量机"}},[a._v("#")]),a._v(" 支持向量机")]),a._v(" "),t("p",[a._v("一条线能将图像分成两部分")]),a._v(" "),t("h1",{attrs:{id:"无监督的机器学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无监督的机器学习"}},[a._v("#")]),a._v(" 无监督的机器学习")]),a._v(" "),t("h2",{attrs:{id:"k-means聚类算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k-means聚类算法"}},[a._v("#")]),a._v(" k-means聚类算法")]),a._v(" "),t("h2",{attrs:{id:"pca算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pca算法"}},[a._v("#")]),a._v(" PCA算法")]),a._v(" "),t("p",[a._v("选取样本方差矩阵的前k个特征值对应的特征向量作为简化后的内容")]),a._v(" "),t("h1",{attrs:{id:"神经网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#神经网络"}},[a._v("#")]),a._v(" 神经网络")]),a._v(" "),t("ul",[t("li",[a._v("数据输入层：对原始图像数据进行预处理")]),a._v(" "),t("li",[a._v("卷积层：得到目标的特征")]),a._v(" "),t("li",[a._v("激活层：将数值压缩到0-1之间，决定了某个神经元是激活还是抛弃")]),a._v(" "),t("li",[a._v("池化层：压缩图像，去掉冗余信息")]),a._v(" "),t("li",[a._v("全连接层：将特征空间映射到样本区间，将之前提取到的特征组合起来，")])])])}),[],!1,null,null,null);t.default=s.exports}}]);