(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{411:function(_,v,t){"use strict";t.r(v);var r=t(7),a=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"主体流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主体流程"}},[_._v("#")]),_._v(" 主体流程")]),_._v(" "),v("p",[_._v("启动流程：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("初始化核心模块的create_conf,生成配置结构")])]),_._v(" "),v("li",[v("p",[_._v("解析命令行参数、配置文件")])]),_._v(" "),v("li",[v("p",[_._v("核心模块的init_conf,初始化 →>继而调用各子模块的init_conf方法")])]),_._v(" "),v("li",[v("p",[_._v("创建文件资源，开启 socket 监听")])]),_._v(" "),v("li",[v("p",[_._v("初始 master进程")])]),_._v(" "),v("li",[v("p",[_._v("所有模块的init_module")])]),_._v(" "),v("li",[v("p",[_._v("启动master, worker进程")])]),_._v(" "),v("li",[v("p",[_._v("调所有模块的init_process 方法")])])]),_._v(" "),v("p",[v("a",{attrs:{href:"%22C:%5CUsers%5Ctypora%5C%E9%9D%A2%E8%AF%95%5Cngx_http_mytest_module.c%22"}},[_._v("http模块例子")])]),_._v(" "),v("p",[_._v("进程循环：")]),_._v(" "),v("p",[_._v("检查各类信号的标识位，并做处理。worker进程是每次循环都会检查信号和执行事件循环，master进程是只有某个信号触发了才会执行一遍循环检查信号")]),_._v(" "),v("p",[_._v("worker进程执行"),v("code",[_._v("ngx_process_events_and_timers")])]),_._v(" "),v("h1",{attrs:{id:"事件处理模块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件处理模块"}},[_._v("#")]),_._v(" 事件处理模块")]),_._v(" "),v("h2",{attrs:{id:"事件驱动架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动架构"}},[_._v("#")]),_._v(" 事件驱动架构：")]),_._v(" "),v("p",[_._v("事件分发器会由多个worker进程随机调用，事件收集器独占进程处理事件")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("异步架构：将阻塞的事件分解为两个阶段，第一阶段非阻塞的send发送，第二阶段查看结果")])]),_._v(" "),v("li",[v("p",[_._v("同步拆分变异步：对于不能异步的，拆份执行时间（将10MB划分成1000份，每次读写10kb发送）")])]),_._v(" "),v("li",[v("p",[_._v("用定时器代替循环检查")])]),_._v(" "),v("li",[v("p",[_._v("如果必须要阻塞，由一个单独的进程阻塞，阻塞完毕后通知分发器")])])]),_._v(" "),v("p",[_._v("事件包括：网络事件和定时器事件")]),_._v(" "),v("p",[v("strong",[_._v("事件初始化：")])]),_._v(" "),v("p",[_._v("ngx_event_core_module模块的init_process函数注册连接事件处理函数")]),_._v(" "),v("p",[v("strong",[_._v("事件循环ngx_epoll_process_events：")])]),_._v(" "),v("ul",[v("li",[_._v("通过缓存数组拿到时间")]),_._v(" "),v("li",[_._v("通过epoll拿到事件并遍历每一个事件")]),_._v(" "),v("li",[_._v("通过指针的最后一位判断事件是否过期，")]),_._v(" "),v("li",[_._v("移入对应的读写post队列or立即处理")])]),_._v(" "),v("p",[_._v("post队列：连接队列、普通读写队列")]),_._v(" "),v("p",[_._v("连接总数=min(worker进程数量*worker_connections（配置文件指定，默认1024），系统文件描述符）")]),_._v(" "),v("p",[_._v("其他：")]),_._v(" "),v("ul",[v("li",[_._v("nginx实现全局负责均衡锁是通过共享内存实现了")]),_._v(" "),v("li",[_._v("这个过程中，可以控制"),v("strong",[_._v("epoll是立即返回")]),_._v("，还是等下一个计时器的事件返回，能影响定时器的精度")]),_._v(" "),v("li",[_._v("可以控制epoll"),v("strong",[_._v("一次处理多少事件")]),_._v("，用于提前分配空间")]),_._v(" "),v("li",[_._v("可以控制"),v("strong",[_._v("延后处理事件")]),_._v("还是立即处理：延后处理可以避免频繁的上下文切换，提高整体性能")])]),_._v(" "),v("h2",{attrs:{id:"连接队列处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接队列处理"}},[_._v("#")]),_._v(" 连接队列处理")]),_._v(" "),v("h2",{attrs:{id:"文件异步io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件异步io"}},[_._v("#")]),_._v(" 文件异步IO")]),_._v(" "),v("p",[_._v("linux内核提供了异步io接口，有如下特点：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("一定会走磁盘")]),_._v("即使内存里有数据，因此使不使用异步io要看情况")])]),_._v(" "),v("li",[v("p",[_._v("linux内核只能"),v("strong",[_._v("异步读")]),_._v("，"),v("strong",[_._v("不能异步写")]),_._v("（linux写操作本身就走的缓存延迟写）")])])]),_._v(" "),v("p",[_._v("初始化时将异步io的文件描述符加入到epoll")]),_._v(" "),v("p",[_._v("事件循环函数调文件异步IO的回调函数，其中，读出数据，加入到读post队列，下次处理post队列时会执行相关的回调处理函数")]),_._v(" "),v("h1",{attrs:{id:"http框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http框架"}},[_._v("#")]),_._v(" http框架")]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240827135752803.png",alt:"http请求的11个阶段"}})]),_._v(" "),v("p",[_._v("事件架构更关注tcp层的传输，贴近底层细节，http更关注http层的传输，更贴近业务")]),_._v(" "),v("p",[_._v("主要有"),v("strong",[_._v("四部分工作：")])]),_._v(" "),v("ul",[v("li",[_._v("集成事件驱动模块，处理读写事件和定时器事件")]),_._v(" "),v("li",[_._v("在不同阶段调度不同http模块")]),_._v(" "),v("li",[_._v("将请求分解为子请求（事件驱动提高了性能但提高了开发难度，因此分解请求降低难度）")]),_._v(" "),v("li",[_._v("提供基本的工具接口，接发包体等")])]),_._v(" "),v("h2",{attrs:{id:"建立连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#建立连接"}},[_._v("#")]),_._v(" 建立连接：")]),_._v(" "),v("p",[_._v("生成一个连接对象")]),_._v(" "),v("h2",{attrs:{id:"当读事件到来时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#当读事件到来时"}},[_._v("#")]),_._v(" 当读事件到来时")]),_._v(" "),v("p",[_._v("第一次到来时生成一个请求对象")]),_._v(" "),v("h2",{attrs:{id:"处理请求头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理请求头"}},[_._v("#")]),_._v(" 处理请求头：")]),_._v(" "),v("p",[_._v("处理请求：")]),_._v(" "),v("p",[_._v("执行11个请求阶段：")]),_._v(" "),v("p",[_._v("对于每一个阶段的checker方法：")]),_._v(" "),v("h2",{attrs:{id:"当写请求到来时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#当写请求到来时"}},[_._v("#")]),_._v(" 当写请求到来时")]),_._v(" "),v("h2",{attrs:{id:"发送包体"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发送包体"}},[_._v("#")]),_._v(" 发送包体")]),_._v(" "),v("p",[_._v("最后一个头部过滤模块会负责打包和发送头部")]),_._v(" "),v("p",[_._v("发送包体类似")]),_._v(" "),v("h1",{attrs:{id:"nginx性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nginx性能优化"}},[_._v("#")]),_._v(" nginx性能优化")]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/./image-20241029221416898.png",alt:"image-20241029221416898"}})]),_._v(" "),v("p",[_._v("网卡、磁盘、cpu、内存")]),_._v(" "),v("h2",{attrs:{id:"cpu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[_._v("#")]),_._v(" cpu")]),_._v(" "),v("p",[_._v("增大cpu的有效时长：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("提高cpu"),v("strong",[_._v("缓存")]),_._v("命中率：")]),_._v(" "),v("ul",[v("li",[_._v("cpu亲和")]),_._v(" "),v("li",[_._v("numa架构，查看命中率，禁止访问远端")]),_._v(" "),v("li",[_._v("优化对象数据结构")])])]),_._v(" "),v("li",[v("p",[_._v("减少"),v("strong",[_._v("进程切换")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("主动切换：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("业务"),v("strong",[_._v("逻辑阻塞")]),_._v("的API")])]),_._v(" "),v("li",[v("p",[_._v("执行"),v("strong",[_._v("慢速的硬件")]),_._v("读写操作")]),_._v(" "),v("p",[_._v("——异步or事件驱动架构")])])])]),_._v(" "),v("li",[v("p",[_._v("被动切换：")]),_._v(" "),v("ul",[v("li",[_._v("其他进程：减少不相干进程，提高当前进程优先级")]),_._v(" "),v("li",[_._v("时间片用完：提高时间片的大小")]),_._v(" "),v("li",[_._v("cpu亲和")]),_._v(" "),v("li",[_._v("合理设置线程/进程数量")]),_._v(" "),v("li",[_._v("使用协程")])])])])])]),_._v(" "),v("p",[_._v("worker进程间负载均衡：")]),_._v(" "),v("ul",[v("li",[_._v("解决惊群问题：负载均衡锁")])]),_._v(" "),v("p",[_._v("卸载cpu：qat技术")]),_._v(" "),v("h2",{attrs:{id:"网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[_._v("#")]),_._v(" 网络")]),_._v(" "),v("h3",{attrs:{id:"整体优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整体优化"}},[_._v("#")]),_._v(" 整体优化")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("多队列网卡对多核CPU优化")])]),_._v(" "),v("li",[v("p",[_._v("tcp：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("连接")]),_._v("：重试次数、端口范围、已连接/半连接队列长度")]),_._v(" "),v("li",[_._v("内存：os、用户、进程、nginx"),v("strong",[_._v("句柄")]),_._v("上限")]),_._v(" "),v("li",[_._v("吞吐量优先，启用"),v("strong",[_._v("nagle算法")]),_._v("，低延时优先，禁用")]),_._v(" "),v("li",[v("strong",[_._v("窗口大小")]),_._v("：bbr")]),_._v(" "),v("li",[v("strong",[_._v("关闭连接")]),_._v("：复用TIME_WAIT，让客户端发起关闭")])]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240905112501405.png",alt:"image-20240905112501405"}})])]),_._v(" "),v("li",[v("p",[_._v("http层：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("握手")]),_._v("：qat加速、使用session缓存、使用会话票证tickets复用之前的连接")]),_._v(" "),v("p",[_._v("、长连接")])]),_._v(" "),v("li",[v("p",[_._v("传输：升级协议，使用quic等更快速的传输方案")])]),_._v(" "),v("li",[v("p",[_._v("包体：压缩包体，提升网络传输效率")])]),_._v(" "),v("li",[v("p",[_._v("丢弃：xudp、dpdk")])])])]),_._v(" "),v("li",[v("p",[_._v("应用层")]),_._v(" "),v("ul",[v("li",[_._v("消息队列")]),_._v(" "),v("li",[_._v("连接复用")]),_._v(" "),v("li",[_._v("定期资源清理、监控")]),_._v(" "),v("li",[_._v("异步编程、")]),_._v(" "),v("li",[_._v("事件驱动架构")]),_._v(" "),v("li",[_._v("负载均衡锁")])])])]),_._v(" "),v("h3",{attrs:{id:"向远端请求大量数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向远端请求大量数据"}},[_._v("#")]),_._v(" 向远端请求大量数据")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("方向")]),_._v(" "),v("th",[_._v("问题")]),_._v(" "),v("th",[_._v("解决")]),_._v(" "),v("th",[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("请求、回复")]),_._v(" "),v("td",[_._v("请求超时、丢失")]),_._v(" "),v("td",[_._v("每个请求发出时注册一个定时器")]),_._v(" "),v("td",[_._v("定时器超时后，记录错误")])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("避免重复发请求")]),_._v(" "),v("td",[_._v("请求上下文记录当前是否在一个请求周期内")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("回复重复")]),_._v(" "),v("td",[_._v("回复计数")]),_._v(" "),v("td",[_._v("发出的请求和收到的回复一致后，结束这一轮请求，执行更新")])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("网络不好导致大量重传")]),_._v(" "),v("td",[_._v("数据分块，每次请求一块，收到后再组装")]),_._v(" "),v("td",[_._v("http头记录总长，每收到一部分累加总长，全部到期后拼接交付")])]),_._v(" "),v("tr",[v("td",[_._v("接收包")]),_._v(" "),v("td",[_._v("内存不足")]),_._v(" "),v("td",[_._v("申请内存失败，记录本轮请求错误")]),_._v(" "),v("td",[_._v("请求结束时，有错误则不执行更新")])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("请求和回复不一致，或字段错误")]),_._v(" "),v("td",[_._v("同上，记录错误")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("速度太慢")]),_._v(" "),v("td",[_._v("压缩+解压")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("大量回复同时到达")]),_._v(" "),v("td",[_._v("以随机时间发出每个请求")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("交付")]),_._v(" "),v("td",[_._v("更新交付数据的时机")]),_._v(" "),v("td",[_._v("请求上下文记录发出和收到的请求数量")]),_._v(" "),v("td",[_._v("数量一致，并且没有错误时，执行更新")])])])]),_._v(" "),v("h3",{attrs:{id:"如何向远端更新本地数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何向远端更新本地数据"}},[_._v("#")]),_._v(" 如何向远端更新本地数据")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("方向")]),_._v(" "),v("th",[_._v("问题")]),_._v(" "),v("th",[_._v("解决")]),_._v(" "),v("th",[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("判断更新")]),_._v(" "),v("td",[_._v("如何比较是否增删")]),_._v(" "),v("td",[_._v("提炼唯一字段作为key，用链表或红黑树维护索引"),v("br"),_._v("遍历一遍，没有遍历到的删除掉")]),_._v(" "),v("td",[_._v("哈希表不利于整体便利一遍，数据小用链表，大也许可以用哈希")])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("描述字段的更新")]),_._v(" "),v("td",[_._v("状态机每解析一个字段比较修改一次")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("数据的更新")]),_._v(" "),v("td",[_._v("每解析到关键描述字段有变化，则发起一个更新请求")]),_._v(" "),v("td",[_._v("md5、key、版本号"),v("br"),_._v("同时创建对应的描述结构体，收到回复时直接填入指针")])]),_._v(" "),v("tr",[v("td",[_._v("接收")]),_._v(" "),v("td",[_._v("回复的数据有误")]),_._v(" "),v("td",[_._v("停止解析，不更新")]),_._v(" "),v("td",[_._v("下次更新时会恢复这个数据/"),v("br"),_._v("或者维持一个更新链表，更新完后加入使用链表里")])]),_._v(" "),v("tr",[v("td",[_._v("交付")]),_._v(" "),v("td",[_._v("如何交付")]),_._v(" "),v("td",[_._v("每次更新时，开启一个请求周期，当收到全部回复时，增加版本号，应用每次比对版本号判断更新")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[_._v("对远端服务器")]),_._v(" "),v("td",[_._v("请求过多，对远端服务器有压力")]),_._v(" "),v("td",[_._v("维持服务器ip表，轮训发送请求")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("本地服务器频繁宕机，频繁请求，对远端服务器有压力")]),_._v(" "),v("td",[_._v("本地持久化一份，每次从持久化里恢复一部分")]),_._v(" "),v("td",[_._v("持久化需要md5校验")])])])]),_._v(" "),v("h3",{attrs:{id:"如何设计程序更新缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何设计程序更新缓存"}},[_._v("#")]),_._v(" 如何设计程序更新缓存")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("方向")]),_._v(" "),v("th",[_._v("问题")]),_._v(" "),v("th",[_._v("解决")]),_._v(" "),v("th",[_._v("描述")])])]),_._v(" "),v("tbody",[v("tr",[v("td"),_._v(" "),v("td",[_._v("阻塞更新（网络/IO）太慢，影响业务")]),_._v(" "),v("td",[_._v("后台异步执行更新，更新完后切换给前台使用")]),_._v(" "),v("td",[_._v("双缓存架构"),v("br"),_._v("如果是后台进程就用共享内存通信，如果是后台线程就用原子变量指向数据地址"),v("br")])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("旧的缓存什么时候释放")]),_._v(" "),v("td",[_._v("需要有计数器，新的请求读到新的缓存，旧的请求全部结束后，计数器清0，释放旧的缓存")]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[_._v("旧的缓存还没释放，新的更新指令又到了")]),_._v(" "),v("td",[_._v("新的更新指令里判断备用缓存的计数器不为0则放弃本次更新")]),_._v(" "),v("td")])])]),_._v(" "),v("h3",{attrs:{id:"内存如何和磁盘比较并更新数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存如何和磁盘比较并更新数据"}},[_._v("#")]),_._v(" 内存如何和磁盘比较并更新数据？")]),_._v(" "),v("h2",{attrs:{id:"磁盘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#磁盘"}},[_._v("#")]),_._v(" 磁盘")]),_._v(" "),v("p",[_._v("读：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("零拷贝")])]),_._v(" "),v("li",[v("p",[_._v("异步读写，wal+追加日志")])]),_._v(" "),v("li",[v("p",[_._v("同步读：对于大文件的io绕过磁盘缓存直接读，避免缓存拷贝/预读+更好的利用预读")])]),_._v(" "),v("li",[v("p",[_._v("对一些数据预读并缓存")])])]),_._v(" "),v("p",[_._v("写：")]),_._v(" "),v("ul",[v("li",[_._v("日志:\n"),v("ul",[v("li",[_._v("减少日志：关闭/压缩access_log、增大error_log级别")]),_._v(" "),v("li",[_._v("重定向写入：将日志写入syslog服务器，而不是磁盘")]),_._v(" "),v("li",[_._v("缓存写：先追加写，缓存起来适当时候统一写")])])]),_._v(" "),v("li",[_._v("启用代理缓存：用户请求无需每次都到业务服务端，部分请求可以直接返回结果")])]),_._v(" "),v("h2",{attrs:{id:"内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存"}},[_._v("#")]),_._v(" 内存")]),_._v(" "),v("p",[_._v("开发：")]),_._v(" "),v("ul",[v("li",[_._v("栈>堆")]),_._v(" "),v("li",[_._v("局部>全局")]),_._v(" "),v("li",[_._v("避免拷贝")]),_._v(" "),v("li",[_._v("精简数据")])]),_._v(" "),v("p",[_._v("内存分配：")]),_._v(" "),v("ul",[v("li",[_._v("tcmalloc替代ptmalloc")]),_._v(" "),v("li",[_._v("池化技术：资源复用，减少系统调用")]),_._v(" "),v("li",[_._v("专门的线程做内存释放")]),_._v(" "),v("li",[_._v("对于大数据启用大页")])]),_._v(" "),v("p",[_._v("读写：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("提高缓存命中率、内存分层")])]),_._v(" "),v("li",[v("p",[_._v("选择合适的算法和数据结构")])])]),_._v(" "),v("p",[_._v("内存不够：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("检查内存泄漏")])]),_._v(" "),v("li",[v("p",[_._v("业务优化：细化变量生命周期，减少重复的数据")])]),_._v(" "),v("li",[v("p",[_._v("部分数据持久化")])]),_._v(" "),v("li",[v("p",[_._v("调整内存和磁盘的交换大小和频率")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);