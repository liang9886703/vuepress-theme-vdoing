(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{416:function(_,v,t){"use strict";t.r(v);var a=t(7),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[_._v("#")]),_._v(" 基本概念")]),_._v(" "),v("h2",{attrs:{id:"进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[_._v("#")]),_._v(" 进程")]),_._v(" "),v("p",[_._v("进程状态：就绪、阻塞、运行、创建、结束、阻塞挂起、就绪挂起")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"image-20240103194819100.png",alt:"image-20240103194819100"}}),_._v(" "),v("p",[_._v("PCB包含：进程描述信息、进程控制管理信息、资源分配清单、CPU运行信息")]),_._v(" "),v("p",[_._v("对进程状态的切换，就是将对应的PCB移入对应的链表")]),_._v(" "),v("h3",{attrs:{id:"创建进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建进程"}},[_._v("#")]),_._v(" "),v("strong",[_._v("创建进程：")])]),_._v(" "),v("p",[_._v("引起的创建进程事件：用户登录、作业调度、提供服务、应用请求")]),_._v(" "),v("ul",[v("li",[_._v("通过clone调用拷贝当前进程并创建一个子进程，填入信息")]),_._v(" "),v("li",[_._v("分配运行所需的资源")]),_._v(" "),v("li",[_._v("插入就绪队列，等待调度")])]),_._v(" "),v("h3",{attrs:{id:"终止进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#终止进程"}},[_._v("#")]),_._v(" "),v("strong",[_._v("终止进程：")])]),_._v(" "),v("p",[_._v("引起终止的事件：正常结束、异常结束（越界、等待超时、算术运算出错）、外界干预（用户和os主动杀死进程，父进程请求，父进程终止）")]),_._v(" "),v("ul",[v("li",[_._v("调用do_exit(), 通过终止进程的标识符找到PCB")]),_._v(" "),v("li",[_._v("若在执行则终止，并重定位子进程（给他找一个父进程）")]),_._v(" "),v("li",[_._v("返还资源给系统和进程")]),_._v(" "),v("li",[_._v("将其PCB从队列移除")])]),_._v(" "),v("h3",{attrs:{id:"阻塞进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#阻塞进程"}},[_._v("#")]),_._v(" "),v("strong",[_._v("阻塞进程：")])]),_._v(" "),v("ul",[v("li",[_._v("通过进程标识号找到对应的PCB")]),_._v(" "),v("li",[_._v("如果其为运行状态，则保存上下文，停止运行")]),_._v(" "),v("li",[_._v("修改其状态，插入到阻塞队列中")])]),_._v(" "),v("h3",{attrs:{id:"唤醒进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#唤醒进程"}},[_._v("#")]),_._v(" "),v("strong",[_._v("唤醒进程：")])]),_._v(" "),v("ul",[v("li",[_._v("在阻塞队列中找到PCB")]),_._v(" "),v("li",[_._v("修改其状态，从阻塞队列移出插入就绪队列")])]),_._v(" "),v("h3",{attrs:{id:"进程切换的步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程切换的步骤"}},[_._v("#")]),_._v(" "),v("strong",[_._v("进程切换的步骤：")])]),_._v(" "),v("ul",[v("li",[_._v("保存当前进程上下文，")]),_._v(" "),v("li",[_._v("更新其PCB，将PCB移入适当的队列")]),_._v(" "),v("li",[_._v("选择其他进程执行，更新和修改其PCB的状态")]),_._v(" "),v("li",[_._v("恢复其进程的上下文环境")])]),_._v(" "),v("p",[_._v("（进程上下文包括，CPU寄存器和程序计数器（记录指令位置））")]),_._v(" "),v("h3",{attrs:{id:"进程切换发生的场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程切换发生的场景"}},[_._v("#")]),_._v(" "),v("strong",[_._v("进程切换发生的场景：")])]),_._v(" "),v("ul",[v("li",[_._v("缺少资源：时间片到期、请求资源或资源不足时（例如内存不足）")]),_._v(" "),v("li",[_._v("主动阻塞：主动睡眠或挂起")]),_._v(" "),v("li",[_._v("被迫阻塞：更高优先级的进程加入、发生硬件中断")])]),_._v(" "),v("h2",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[_._v("#")]),_._v(" 线程")]),_._v(" "),v("p",[_._v("同一个进程内线程共享代码段、数据段、系统资源")]),_._v(" "),v("h3",{attrs:{id:"线程和进程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程的区别"}},[_._v("#")]),_._v(" "),v("strong",[_._v("线程和进程的区别：")])]),_._v(" "),v("p",[_._v("目的：")]),_._v(" "),v("ul",[v("li",[_._v("线程是CPU"),v("strong",[_._v("调度")]),_._v("的单位，进程"),v("strong",[_._v("资源")]),_._v("的分配单位，")])]),_._v(" "),v("p",[_._v("成本：")]),_._v(" "),v("ul",[v("li",[_._v("线程本身只有独立的寄存器和栈")])]),_._v(" "),v("p",[_._v("运行：")]),_._v(" "),v("ul",[v("li",[_._v("线程"),v("strong",[_._v("切换")]),_._v("、创建、终止的开销小，进程切换开销大")]),_._v(" "),v("li",[_._v("如果如果"),v("strong",[_._v("线程崩溃")]),_._v("了，导致所属进程都崩溃了（c++)")])]),_._v(" "),v("p",[_._v("开发：")]),_._v(" "),v("ul",[v("li",[_._v("进程之间"),v("strong",[_._v("通信")]),_._v("需通过系统，开销大，效率低，同进程的线程通信可直接读写，方便且快捷，但也存在资源互斥的问题")])]),_._v(" "),v("h3",{attrs:{id:"内核线程和用户线程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内核线程和用户线程的区别"}},[_._v("#")]),_._v(" "),v("strong",[_._v("内核线程和用户线程的区别：")])]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240226161438902.png",alt:"image-20240226161438902"}})]),_._v(" "),v("h3",{attrs:{id:"线程、进程、协程切换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程、进程、协程切换"}},[_._v("#")]),_._v(" 线程、进程、协程切换")]),_._v(" "),v("p",[_._v("都有的，程序计数器、堆栈指针，通用寄存器（上下文）、浮点寄存器、状态寄存器")]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240902210106426.png",alt:"image-20240902210106426"}})]),_._v(" "),v("p",[v("strong",[_._v("协程切换：")])]),_._v(" "),v("p",[_._v("目的：")]),_._v(" "),v("ol",[v("li",[_._v("协程适用于大量"),v("strong",[_._v("I/O密集任务")]),_._v("，涉及资源的等待。线程适用"),v("strong",[_._v("cpu密集")]),_._v("任务")])]),_._v(" "),v("p",[_._v("原理：")]),_._v(" "),v("ol",[v("li",[_._v("系统："),v("strong",[_._v("没有调度程序")]),_._v("执行，但有用户态程序自己写的调度任务，包括保存上下文信息。")]),_._v(" "),v("li",[_._v("系统："),v("strong",[_._v("没有线程切换")]),_._v("的开销（内核态切换），多个协程充分利用所属线程"),v("strong",[_._v("时间片")]),_._v("，提高cpu的有效运行时间")]),_._v(" "),v("li",[_._v("内存：多个协程共享线程的"),v("strong",[_._v("堆栈")]),_._v("，每个线程有自己的堆栈")]),_._v(" "),v("li",[_._v("内存："),v("strong",[_._v("缓存")]),_._v("更容易命中")])]),_._v(" "),v("p",[_._v("开发：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("并发模型："),v("strong",[_._v("协程通常是用事件驱动机制驱动，多个协程在同一个线程跑，因此不涉及多线程并发问题，对")]),_._v("编程来说更友好")]),_._v("（对单个协程来说，运行时的值多次读不会改变）")]),_._v(" "),v("li",[_._v("对系统的适配更好，内核级线程需要系统支持")])]),_._v(" "),v("p",[_._v("对应的，协程阻塞会让在这个线程上的所有协程阻塞")]),_._v(" "),v("p",[v("strong",[_._v("线程切换：")])]),_._v(" "),v("ol",[v("li",[_._v("线程调度程序（决定调度谁），通常比进程的调度代价小")])]),_._v(" "),v("p",[_._v("缓存无法命中：")]),_._v(" "),v("ul",[v("li",[_._v("L1、L2、L3缓存")]),_._v(" "),v("li",[_._v("快表缓存")]),_._v(" "),v("li",[_._v("部分寄存器")])]),_._v(" "),v("p",[v("strong",[_._v("进程切换：")])]),_._v(" "),v("ol",[v("li",[_._v("程序调度程序")]),_._v(" "),v("li",[_._v("进程地址空间：虚拟地址映射结构（段、页基地址寄存器）")]),_._v(" "),v("li",[_._v("快表TLB")])]),_._v(" "),v("p",[_._v("都通过schedule调度")]),_._v(" "),v("h3",{attrs:{id:"openssl实现的协程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#openssl实现的协程"}},[_._v("#")]),_._v(" openssl实现的协程")]),_._v(" "),v("p",[_._v("封装了linux提供的"),v("code",[_._v("getcontext、makecontext、swapcontext")]),_._v("函数")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://catbro666.github.io/posts/6d5be1a5/#more",target:"_blank",rel:"noopener noreferrer"}},[_._v("OpenSSL的async异步框架/OpenSSL协程 | CatBro's Blog (catbro666.github.io)"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("只被async框架使用，用于异步握手")]),_._v(" "),v("p",[_._v("assync框架用一个job来表示一个协程，")]),_._v(" "),v("p",[_._v("协程的堆栈信息、协程的通知文件描述符、协程间通信的内容，都存放在线程的私有变量中")]),_._v(" "),v("p",[_._v("openssl利用async来实现异步握手")]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240822152556204.png",alt:"image-20240822152556204"}})]),_._v(" "),v("h2",{attrs:{id:"对于线程模式的选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于线程模式的选择"}},[_._v("#")]),_._v(" 对于线程模式的选择")]),_._v(" "),v("p",[v("strong",[_._v("1：1模式")])]),_._v(" "),v("p",[_._v("一个用户线程对应一个内核线程")]),_._v(" "),v("p",[_._v("容易实现，可以并行")]),_._v(" "),v("p",[_._v("每个用户线程创建一个内核线程开销太大")]),_._v(" "),v("p",[v("strong",[_._v("N：1模式")])]),_._v(" "),v("p",[_._v("多个用户线程对应一个内核线程")]),_._v(" "),v("p",[_._v("用户线程上下文切换效率高")]),_._v(" "),v("p",[_._v("一个用户线程阻塞会将其他用户线程也阻塞，且只能使用单核的CPU资源")]),_._v(" "),v("p",[v("strong",[_._v("N:N模式")])]),_._v(" "),v("p",[_._v("多个用户线程对应多个LWP，LWP再一一对应内核线程")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"image-20240103202500541.png",alt:"image-20240103202500541"}}),_._v(" "),v("h2",{attrs:{id:"进程的调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的调度"}},[_._v("#")]),_._v(" 进程的调度")]),_._v(" "),v("h3",{attrs:{id:"处理器调度层次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理器调度层次"}},[_._v("#")]),_._v(" 处理器调度层次")]),_._v(" "),v("ul",[v("li",[_._v("作业调度：把处于后备队列的作业调入内存，创建进程、分配资源")]),_._v(" "),v("li",[_._v("进程调度")]),_._v(" "),v("li",[_._v("中程调度：将不能运行的进程调值外存上等待")])]),_._v(" "),v("h3",{attrs:{id:"调度原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度原则"}},[_._v("#")]),_._v(" 调度原则")]),_._v(" "),v("ul",[v("li",[_._v("CPU利用率")]),_._v(" "),v("li",[_._v("系统吞吐量")]),_._v(" "),v("li",[_._v("带权周转时间=（作业完成时间-作业提交时间）/实际运行时间")]),_._v(" "),v("li",[_._v("等待时间（所有进程等待时间之和）")]),_._v(" "),v("li",[_._v("响应时间（用户提交请求到首次相应）")])]),_._v(" "),v("h3",{attrs:{id:"调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[_._v("#")]),_._v(" 调度算法")]),_._v(" "),v("ul",[v("li",[_._v("先来先服务算法FCFS")]),_._v(" "),v("li",[_._v("短作业优先调度SJF")]),_._v(" "),v("li",[_._v("优先级调度（实时操作系统）")]),_._v(" "),v("li",[_._v("高响应比优先调度算法（ （等待时间+预计服务时间）/预计服务时间）")]),_._v(" "),v("li",[_._v("时间片轮转调度算法RR")]),_._v(" "),v("li",[_._v("多级反馈队列调度算法")])]),_._v(" "),v("h1",{attrs:{id:"进程的通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的通信"}},[_._v("#")]),_._v(" 进程的通信")]),_._v(" "),v("h2",{attrs:{id:"管道"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[_._v("#")]),_._v(" 管道")]),_._v(" "),v("p",[_._v("简单且基础的通信方式")]),_._v(" "),v("p",[v("strong",[_._v("匿名管道")]),_._v("：实际上是特殊的存在于内存的一串缓存")]),_._v(" "),v("p",[_._v("使用，用pipe创建读写描述符，使用fork()创建子进程，此时父子进程通过读写描述符通信")]),_._v(" "),v("p",[_._v("**命名管道：**实际是创建了一个类型为管道的设备文件")]),_._v(" "),v("p",[v("strong",[_._v("缺点：")])]),_._v(" "),v("ul",[v("li",[_._v("常用于"),v("strong",[_._v("父子进程通信")]),_._v("，"),v("strong",[_._v("不能同时读写")]),_._v("，如果要双向通信就需要建两个管道")]),_._v(" "),v("li",[_._v("管道是个"),v("strong",[_._v("环形缓冲区")]),_._v("：一次"),v("strong",[_._v("数据大小")]),_._v("有上限")]),_._v(" "),v("li",[_._v("数据读完就删除")]),_._v(" "),v("li",[_._v("管道慢")])]),_._v(" "),v("p",[v("strong",[_._v("管道慢的原因：")])]),_._v(" "),v("ul",[v("li",[_._v("写时数据从用户"),v("strong",[_._v("内存复制")]),_._v("到内核，读时数据从内核复制到用户空间")]),_._v(" "),v("li",[_._v("处理期间要获取和释放"),v("strong",[_._v("管道锁")])]),_._v(" "),v("li",[_._v("不断分配新页面，可能处理的数据内存不连续")])]),_._v(" "),v("h2",{attrs:{id:"消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[_._v("#")]),_._v(" 消息队列")]),_._v(" "),v("p",[_._v("是保存在内核中的消息链表，发送数据时，会分成一个个独立的数据单元，发送接收双方约定好消息体的数据类型（固定大小）")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("通信对象")]),_._v("："),v("strong",[_._v("多个进程")]),_._v("间发送接收消息，可以实现复杂的进程通信，但"),v("strong",[_._v("读写消息时互斥")]),_._v("，且"),v("strong",[_._v("通信不及时")])]),_._v(" "),v("li",[v("strong",[_._v("功能")]),_._v("：复杂而功能强大， 消息有"),v("strong",[_._v("类型和优先级")])]),_._v(" "),v("li",[v("strong",[_._v("数据大小")]),_._v("：能通信的"),v("strong",[_._v("数据大小")]),_._v("远大于管道，但仍然有上限")]),_._v(" "),v("li",[v("strong",[_._v("删除")]),_._v("：消息队列的生命周期同系统，独立于接发进程，消息读取后仍在队列，可以"),v("strong",[_._v("控制什么时候删除")])]),_._v(" "),v("li",[v("strong",[_._v("时间")]),_._v("：依然存在用户态和内核态"),v("strong",[_._v("数据拷贝")]),_._v("的开销")])]),_._v(" "),v("h2",{attrs:{id:"信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[_._v("#")]),_._v(" 信号量")]),_._v(" "),v("p",[_._v("是一个整型的计数器，用于实现进程间的同步和互斥")]),_._v(" "),v("p",[_._v("P操作：将信号量-1，如果信号量小于0则表示资源占有，阻塞当前进程，不小0则继续运行")]),_._v(" "),v("p",[_._v("V操作：将信号量+1，如果信号量<=0，表示有进程在请求资源，从阻塞的队列中唤醒一个进程")]),_._v(" "),v("h2",{attrs:{id:"共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),v("p",[_._v("拿出一块虚拟地址空间，映射到相同的物理内存")]),_._v(" "),v("ul",[v("li",[_._v("多进程通信")]),_._v(" "),v("li",[_._v("简单但高效，避免了复制的开销")])]),_._v(" "),v("p",[_._v("但多个进程对共享内存存在并发读写的问题，因此需要信号量机制")]),_._v(" "),v("p",[_._v("应用：网络编程中，将文件发送到网上，DMA方式，直接内存映射")]),_._v(" "),v("h2",{attrs:{id:"信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[_._v("#")]),_._v(" 信号")]),_._v(" "),v("p",[_._v("对于异常情况下的工作模式可以通过信号来通知进程")]),_._v(" "),v("p",[_._v("进程间通信机制中唯一的异步通信机制，ctrl+c生成SIGINT信号，kill命令，是SIGKILL信号")]),_._v(" "),v("p",[_._v("用户进程对信号的处理方式：")]),_._v(" "),v("ol",[v("li",[_._v("执行默认操作，linux对信号规定了默认操作")]),_._v(" "),v("li",[_._v("捕捉信号，为信号定义一个处理函数，信号发生时，执行一个处理函数")]),_._v(" "),v("li",[_._v("忽略信号，")])]),_._v(" "),v("p",[_._v("SIGKILL和SEGSTOP是无法捕捉和忽略的")]),_._v(" "),v("p",[_._v("缺点：")]),_._v(" "),v("ol",[v("li",[_._v("异步的信号处理函数可能在主程序的任何时候调用，因此信号处理函数：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("不执行不可重入的函数：信号处理函数里可能和主程序都执行了同一个不可重入函数")])]),_._v(" "),v("li",[v("p",[_._v("不依赖不可重入的资源")])]),_._v(" "),v("li",[v("p",[_._v("不使用静态/全局变量：信号处理函数里读到的程序里的值可能是没有完全写好的数据")])])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("信号处理函数执行的过程中又收到信号，从而"),v("strong",[_._v("信号嵌套")]),_._v("：设置信号掩码")])]),_._v(" "),v("blockquote",[v("p",[_._v("nginx中，信号处理函数只设置标识位（为了让信号处理函数简短），主进程里有信号发送就会被唤醒，并设置信号掩码（这两个是由系统函数提供的支持是同时发送的），循环依次判断每个标识位，执行对应的处理函数")])]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[_._v("移植性：不同os对信号处理的 方式不同，换了系统可能信号处理代码不能正常工作")])]),_._v(" "),v("h2",{attrs:{id:"socket"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[_._v("#")]),_._v(" socket")]),_._v(" "),v("p",[_._v("用于不同主机的通信")]),_._v(" "),v("h1",{attrs:{id:"死锁问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁问题"}},[_._v("#")]),_._v(" 死锁问题")]),_._v(" "),v("h2",{attrs:{id:"死锁预防"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁预防"}},[_._v("#")]),_._v(" 死锁预防")]),_._v(" "),v("p",[v("img",{attrs:{src:"/%E9%9D%A2%E8%AF%95/image-20240104194319151.png",alt:"image-20240104194319151"}})]),_._v(" "),v("h2",{attrs:{id:"死锁避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁避免"}},[_._v("#")]),_._v(" 死锁避免")]),_._v(" "),v("p",[_._v("银行家算法")]),_._v(" "),v("h2",{attrs:{id:"死锁解除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁解除"}},[_._v("#")]),_._v(" 死锁解除")]),_._v(" "),v("p",[_._v("资源剥夺法：挂起某些死锁进程，抢占它的资源")]),_._v(" "),v("p",[_._v("撤销进程法：强制撤销部分进程并剥夺其资源（实现简单代价大）")]),_._v(" "),v("p",[_._v("进程回退法：系统提前设置还原点，回退到足以回避死锁的地步")]),_._v(" "),v("h1",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[_._v("#")]),_._v(" 锁")]),_._v(" "),v("h2",{attrs:{id:"互斥锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[_._v("#")]),_._v(" 互斥锁")]),_._v(" "),v("p",[_._v("互斥锁加锁失败后，会从用户态陷入到内核态，内核会将线程置为睡眠状态，切换线程，等到锁被释放后，内核在合适的时机唤醒线程。")]),_._v(" "),v("p",[_._v("这个主要的开销成本，包含两次线程上下文切换的成本：")]),_._v(" "),v("ul",[v("li",[_._v("当线程加锁失败时，内核把线程的状态从运行状态设置为睡眠状态，把CPU切换给其他线程")]),_._v(" "),v("li",[_._v("锁释放时，睡眠状态的线程会变为就绪状态，下次调度时运行")])]),_._v(" "),v("h2",{attrs:{id:"自旋锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[_._v("#")]),_._v(" 自旋锁")]),_._v(" "),v("blockquote",[v("p",[_._v("上下文切换的耗时约在几十纳秒到几微妙之间，如果被锁住的代码执行时间很短，用自旋锁代替互斥锁会更合适")])]),_._v(" "),v("p",[_._v("自旋锁是通过CPU提供的CAS函数，在用户态完成加锁解锁，不主动产生上下文切换，开销小，速度块")]),_._v(" "),v("p",[_._v("自旋锁的加锁过程：")]),_._v(" "),v("ul",[v("li",[_._v("查看锁的状态，如果锁是空闲的，执行第二步")]),_._v(" "),v("li",[_._v("第二步，将锁设置为当前线程持有")])]),_._v(" "),v("p",[_._v("CAS函数将这两个步骤合并成一条硬件指令，形成原子指令")]),_._v(" "),v("p",[_._v("在单核CPU上，使用自旋锁需要抢占式的调度器，毕竟自旋的线程不会主动放弃CPU")]),_._v(" "),v("h1",{attrs:{id:"进程的预读策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的预读策略"}},[_._v("#")]),_._v(" 进程的预读策略")]),_._v(" "),v("p",[_._v("几个核心规则：")]),_._v(" "),v("ul",[v("li",[_._v("预读的时候内核并不考虑页内偏移，逐页读取即为顺序读")]),_._v(" "),v("li",[_._v("进程持续顺序访问一个文件，那么预读页数逐步增加。进程随机访问文件，内核就会逐步减少预读")]),_._v(" "),v("li",[_._v("内核发现进程重复访问同一页或文件页全部在缓存页中，则禁止预读")])]),_._v(" "),v("h1",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[_._v("#")]),_._v(" 其他")]),_._v(" "),v("h2",{attrs:{id:"一个进程能创建多少线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一个进程能创建多少线程"}},[_._v("#")]),_._v(" 一个进程能创建多少线程")]),_._v(" "),v("p",[_._v("收到如下的限制")]),_._v(" "),v("ul",[v("li",[_._v("进程的虚拟内存空间上限：一个进程或线程的最大栈大小通常为8M，"),v("code",[_._v("ulimit -s")])]),_._v(" "),v("li",[v("em",[v("strong",[_._v("/proc/sys/kernel/threads-max")])]),_._v("，表示"),v("strong",[_._v("系统支持的最大线程数")]),_._v("，默认14553")]),_._v(" "),v("li",[v("em",[v("strong",[_._v("/proc/sys/kernel/pid_max")])]),_._v("，表示系统全局的 "),v("strong",[_._v("PID 号数值")]),_._v("的限制")]),_._v(" "),v("li",[v("em",[v("strong",[_._v("/proc/sys/vm/max_map_count")])]),_._v("，限制一个进程可以拥有的"),v("strong",[_._v("VMA(虚拟内存区域)")])])]),_._v(" "),v("h2",{attrs:{id:"进程是如何崩溃的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程是如何崩溃的"}},[_._v("#")]),_._v(" 进程是如何崩溃的")]),_._v(" "),v("p",[_._v("c++中，各个线程的地址空间是共享的，某个线程对地址的非法访问会导致内存的不确定性，从而影响整个进程，从而使得操作系统让整体崩溃")]),_._v(" "),v("p",[_._v("信号机制实现使进程崩溃")]),_._v(" "),v("p",[_._v("kill指令执行的是系统调用，由内核给指定进程发送信号：")]),_._v(" "),v("ol",[v("li",[_._v("进程收到系统发的信号，CPU暂停运行，将控制权转移给os")]),_._v(" "),v("li",[_._v("调用kill系统调用向进程发送信")]),_._v(" "),v("li",[_._v("操作系统根据情况执行相应的信号处理程序")])]),_._v(" "),v("p",[_._v("这个信号处理函数，一般系统有默认的信号处理程序，但如果用户程序注册了，则执行自己的信号处理函数。")]),_._v(" "),v("h1",{attrs:{id:"排序算法的稳定性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的稳定性"}},[_._v("#")]),_._v(" 排序算法的稳定性：")]),_._v(" "),v("p",[_._v("不稳定：堆、快、选择、希")])])}),[],!1,null,null,null);v.default=s.exports}}]);