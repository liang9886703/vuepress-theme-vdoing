---
title: 设计模式
date: 2025-02-15 22:29:49
permalink: /05/13/26
categories: 
  - 05
  - 13
tags: 
author:
  name: songkuakua
  link: https://github.com/liang9886703
---
| 组件协作（通过晚期绑定，实现框架与应用程序之间的松耦合）     | **模板方法**                 | 行为型 |                                                              | 开放封闭原则  良好扩展性 良好复用性                          | 类个数增加  模板改动，子类均要改                             |
| ------------------------------------------------------------ | ---------------------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              | **战略**                     | 行为型 |                                                              | 封装（透明性好）  开放封闭原则  便于管理算法族  避免使用多重条件语句 | 客户端需要了解每种策略  类数量增加                           |
|                                                              | **观察者模式**               | 行为型 |                                                              | 针对接口编程  良好扩展性  提供了稳定的信息更新传递机制       | 性能问题（观察者过多时） 某个观察者出现卡顿，可能影响整个进程 |
| 单一职责                                                     | **装饰者**                   | 结构型 |                                                              | 开放封闭原则  封装（透明性好）  良好扩展性  灵活性好(扩展更灵活) |                                                              |
|                                                              | **桥接模式**                 | 结构型 |                                                              | 开放封闭原则  封装（透明性好）  良好扩展性  解耦             | 使用场景有限制。只有系统有两个以上独立变化维度时才适用。     |
| 对象创建(工厂子类决定实例化哪一个产品类, 不需要知道它如何生产的，直接从工厂拿到产品即可。) | **工厂模式**                 | 创建型 |                                                              | 封装（透明性好）  开放封闭原则  解耦(使用者只需要知道产品，不关注具体实现) | 代码量大（每加一个产品，都要加一个工厂子类） 不利于扩展复杂的产品结构 |
|                                                              | **抽象工厂模式**             | 创建型 |                                                              | 具体产品类在具体工厂的实现中进行了分离 当客户想要改变整个产品族时，只需要切换具体工厂即可 利于产品一致性 | 不利于添加新种类产品（每添加，具体工厂都要拓展）             |
|                                                              | **原型模式**                 | 创建型 |                                                              | 简单高效  可动态地获取当前原型的状态 允许动态增加或减少产品类 | 每个类都需要配备一个clone函数 若对已有的类进行改造，违背了 开放封闭原则 |
|                                                              | **建造者模式**               | 创建型 |                                                              | 封装（透明性好）(封装了主要业务逻辑)  解耦（产品和建造解耦，相同的建造过程可以创建出不同的产品）  良好扩展性  产品建造过程精细化（将复杂的步骤拆解得到多个相对简单的步骤） | 限制了多样性（产品的组成部分和构建过程要一致） 产品有 **结构上的变化**，则整个系统都要改 |
| 对象性能                                                     | **单例模式**                 | 创建型 | 类中有**唯一静态私有对象 私有化构造函数（ **阻止多个对象的创建）**  **提供了访问接口 | 减少内存资源开销                                             |                                                              |
|                                                              | **享元模式**                 | 结构型 |                                                              | 减少内存资源开销  **提高系统运行效率**                       | **维护共享对象，需要额外开销**。  系统复杂度提高             |
| 接口隔离:                                                    | **门面模式**                 | 结构型 |                                                              | 封装（透明性好）  简单高效  系统稳定性  系统独立性           | 开放封闭原则  系统复杂度提高(解子系统间的业务逻辑关系,才能比较好的封装） |
|                                                              | **代理模式**                 | 结构型 |                                                              | 单一职责原则  封装（透明性好）  解耦（不同抽象间的耦合程度低。）  良好扩展性 | 系统复杂度提高  请求速度降低                                 |
|                                                              | **中介者模式（仲裁者模式）** | 行为型 |                                                              | 良好扩展性  解耦（不同抽象间的耦合程度低。） 集中交互，便于管理 | 中介者的职责很重要，且复杂                                   |
|                                                              | **适配器模式、包装模式**     | 结构型 |                                                              | 封装（透明性好）  解耦  良好复用性  良好扩展性               | 系统复杂度提高                                               |
| 状态变化                                                     | **备忘录模式**               | 行为型 |                                                              | 封装（透明性好）  单一职责原则                               | 不同内部状态的存储，会导致开销增加                           |
|                                                              | **状态模式**                 | 行为型 |                                                              | 封装（透明性好）  良好扩展性  避免使用多重条件语句           | 类个数增加（状态数量增加）                                   |
| 数据结构                                                     | **组合模式**                 | 结构型 |                                                              | 结构 清晰 一致性 节点自由度高                                | 接口隔离原则 应用场景限制                                    |
|                                                              | **迭代器**                   | 行为型 |                                                              | 单一职责原则  开放封闭原则  封装（透明性好）  良好扩展性     | 系统复杂度提高类个数增加                                     |
|                                                              | **责任链模式**               | 行为型 |                                                              | 解耦（请求者和处理者解耦） 比较灵活                          | 性能问题  不一定确保请求完整处理                             |
| 行为变化                                                     | **命令模式**                 | 行为型 |                                                              | 解耦  良好扩展性  有效的管理命令                             | 类个数增加（命令）                                           |
|                                                              | **访问者模式**               | 行为型 |                                                              | 单一职责原则  良好扩展性  解耦                               | 依赖倒置原则  封装（透明性好）  不易增加元素类               |
| 领域问题：                                                   | ***\*解释器模式\****         | 行为型 |                                                              | 良好扩展性  简单高效                                         | 性能问题(执行效率低)  类个数增加                             |

