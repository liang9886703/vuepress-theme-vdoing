---
title: 进程管理
date: 2025-02-13 23:10:50
permalink: /04/07
categories: 
  - 04
tags: 
author:
  name: songkuakua
  link: https://github.com/liang9886703
---
# 基本概念

## 进程

进程状态：就绪、阻塞、运行、创建、结束、阻塞挂起、就绪挂起

<img src="image-20240103194819100.png" alt="image-20240103194819100" style="zoom:50%;" />

PCB包含：进程描述信息、进程控制管理信息、资源分配清单、CPU运行信息

对进程状态的切换，就是将对应的PCB移入对应的链表

### **创建进程：**

引起的创建进程事件：用户登录、作业调度、提供服务、应用请求

- 通过clone调用拷贝当前进程并创建一个子进程，填入信息
- 分配运行所需的资源
- 插入就绪队列，等待调度

### **终止进程：**

引起终止的事件：正常结束、异常结束（越界、等待超时、算术运算出错）、外界干预（用户和os主动杀死进程，父进程请求，父进程终止）

- 调用do_exit(), 通过终止进程的标识符找到PCB
- 若在执行则终止，并重定位子进程（给他找一个父进程）
- 返还资源给系统和进程
- 将其PCB从队列移除

### **阻塞进程：**

- 通过进程标识号找到对应的PCB
- 如果其为运行状态，则保存上下文，停止运行
- 修改其状态，插入到阻塞队列中

### **唤醒进程：**

- 在阻塞队列中找到PCB
- 修改其状态，从阻塞队列移出插入就绪队列

### **进程切换的步骤：**

- 保存当前进程上下文，
- 更新其PCB，将PCB移入适当的队列
- 选择其他进程执行，更新和修改其PCB的状态
- 恢复其进程的上下文环境

（进程上下文包括，CPU寄存器和程序计数器（记录指令位置））

### **进程切换发生的场景：**

- 缺少资源：时间片到期、请求资源或资源不足时（例如内存不足）
- 主动阻塞：主动睡眠或挂起
- 被迫阻塞：更高优先级的进程加入、发生硬件中断

## 线程

同一个进程内线程共享代码段、数据段、系统资源

### **线程和进程的区别：**

- 进程是资源的分配单位，线程是CPU调度的单位
- 进程拥有完整的资源，线程本身只有独立的寄存器和栈
- 线程切换、创建、终止的开销小，进程切换开销大
- 进程之间通信需通过系统，开销大，效率低，同进程的线程通信可直接读写，方便且快捷，但也存在资源互斥的问题

- 如果如果线程崩溃了，导致所属进程都崩溃了（c++)
- 线程对资源的访问大多都有线程安全问题，存在资源互斥

**线程切换和进程切换**

对进程会有更多的寄存器切换，比如页表基地址寄存器、TLB缓存，导致更多的缓存失效。线程切换只有线程特有的栈信息和寄存器状态需要切换，进程切换有更多内容



### **内核线程和用户线程的区别：**

![image-20240226161438902](/操作系统/C:\Users\mine\AppData\Roaming\Typora\typora-user-images\image-20240226161438902.png)

## 轻量级进程LWP

内核线程，在LWP之上还可以使用用户线程，LWP与普通进程的区别在于它只有一个最小的执行上下文和调度程序所需的统计信息，由内核管理和普通进程一样调度

## 对于线程模式的选择

**1：1模式**

一个用户线程对应一个内核线程

容易实现，可以并行

每个用户线程创建一个内核线程开销太大

**N：1模式**

多个用户线程对应一个内核线程

用户线程上下文切换效率高

一个用户线程阻塞会将其他用户线程也阻塞，且只能使用单核的CPU资源

**N:N模式**

多个用户线程对应多个LWP，LWP再一一对应内核线程

<img src="image-20240103202500541.png" alt="image-20240103202500541" style="zoom:50%;" />

## 进程的调度

### 处理器调度层次

- 作业调度：把处于后备队列的作业调入内存，创建进程、分配资源
- 进程调度
- 中程调度：将不能运行的进程调值外存上等待

### 调度原则

- CPU利用率
- 系统吞吐量
- 带权周转时间=（作业完成时间-作业提交时间）/实际运行时间
- 等待时间（所有进程等待时间之和）
- 响应时间（用户提交请求到首次相应）

### 调度算法

- 先来先服务算法FCFS
- 短作业优先调度SJF
- 优先级调度（实时操作系统）
- 高响应比优先调度算法（ （等待时间+预计服务时间）/预计服务时间）
- 时间片轮转调度算法RR
- 多级反馈队列调度算法



# 进程的通信

## 管道

简单且基础的通信方式

**匿名管道**：实际上是特殊的存在于内存的一串缓存


使用，用pipe创建读写描述符，使用fork()创建子进程，此时父子进程通过读写描述符通信

常用于**父子进程通信**，**不能同时读写**，如果要双向通信就需要建两个管道

**命名管道：**实际是创建了一个类型为管道的设备文件

可以双向传输，常用于两个任意进程间的通信，进程终止后依然存在知道被显示删除

**缺点：**

- 一次**数据大小**有上限
- 数据读完就删除
- 管道慢

**管道慢的原因：**

管道是个环形缓冲区

- 写时数据从用户**内存复制**到内核，读时数据从内核复制到用户空间
- 处理期间要获取和释放**管道锁**
- 不断分配新页面，可能处理的数据内存不连续

## 消息队列

是保存在内核中的消息链表，发送数据时，会分成一个个独立的数据单元，发送接收双方约定号消息体的数据类型（固定大小）

- **多个进程**间发送接收消息，可以实现复杂的进程通信，但**读写消息时互斥**，且**通信不及时**
- 复杂而功能强大， 消息有**类型和优先级**
- 能通信的**数据大小**远大于管道，但仍然有上限
- 消息队列的生命周期同系统，独立于接发进程，消息读取后仍在队列，可以**控制什么时候删除**
- 依然存在用户态和内核态**数据拷贝**的开销

## 信号量

是一个整型的计数器，用于实现进程间的同步和互斥

P操作：将信号量-1，如果信号量小于0则表示资源占有，阻塞当前进程，不小0则继续运行

V操作：将信号量+1，如果信号量<=0，表示有进程在请求资源，从阻塞的队列中唤醒一个进程

## 共享内存

拿出一块虚拟地址空间，映射到相同的物理内存

- 多进程通信
- 简单但高效，避免了复制的开销

但多个进程对共享内存存在并发读写的问题，因此需要信号量机制

## 信号

对于异常情况下的工作模式可以通过信号来通知进程

进程间通信机制中唯一的异步通信机制，ctrl+c生成SIGINT信号，kill命令，是SIGKILL信号

用户进程对信号的处理方式：

1. 执行默认操作，linux对信号规定了默认操作
2. 捕捉信号，为信号定义一个处理函数，信号发生时，执行一个处理函数
3. 忽略信号，

SIGKILL和SEGSTOP是无法捕捉和忽略的

## socket

用于不同主机的通信

# 死锁问题

## 死锁预防

![image-20240104194319151](/操作系统/image-20240104194319151.png)

## 死锁避免

银行家算法

## 死锁解除

资源剥夺法：挂起某些死锁进程，抢占它的资源

撤销进程法：强制撤销部分进程并剥夺其资源（实现简单代价大）

进程回退法：系统提前设置还原点，回退到足以回避死锁的地步

# 锁

## 互斥锁

互斥锁加锁失败后，会从用户态陷入到内核态，内核会将线程置为睡眠状态，切换线程，等到锁被释放后，内核在合适的时机唤醒线程。

这个主要的开销成本，包含两次线程上下文切换的成本：

- 当线程加锁失败时，内核把线程的状态从运行状态设置为睡眠状态，把CPU切换给其他线程
- 锁释放时，睡眠状态的线程会变为就绪状态，下次调度时运行

## 自旋锁

> 上下文切换的耗时约在几十纳秒到几微妙之间，如果被锁住的代码执行时间很短，用自旋锁代替互斥锁会更合适

自旋锁是通过CPU提供的CAS函数，在用户态完成加锁解锁，不主动产生上下文切换，开销小，速度块

自旋锁的加锁过程：

- 查看锁的状态，如果锁是空闲的，执行第二步
- 第二步，将锁设置为当前线程持有

CAS函数将这两个步骤合并成一条硬件指令，形成原子指令

在单核CPU上，使用自旋锁需要抢占式的调度器，毕竟自旋的线程不会主动放弃CPU

# 进程的预读策略

几个核心规则：

- 预读的时候内核并不考虑页内偏移，逐页读取即为顺序读
- 进程持续顺序访问一个文件，那么预读页数逐步增加。进程随机访问文件，内核就会逐步减少预读
- 内核发现进程重复访问同一页或文件页全部在缓存页中，则禁止预读



# 其他



## 一个进程能创建多少线程

收到如下的限制

- 进程的虚拟内存空间上限：一个进程或线程的最大栈大小通常为8M，`ulimit -s`
- ***/proc/sys/kernel/threads-max***，表示**系统支持的最大线程数**，默认14553
- ***/proc/sys/kernel/pid_max***，表示系统全局的 **PID 号数值**的限制
- ***/proc/sys/vm/max_map_count***，限制一个进程可以拥有的**VMA(虚拟内存区域)**

## 进程是如何崩溃的

c++中，各个线程的地址空间是共享的，某个线程对地址的非法访问会导致内存的不确定性，从而影响整个进程，从而使得操作系统让整体崩溃

通常线程崩溃不会让进程崩溃，但默认的信号处理函数收到中断信号后会停止进程

信号机制实现使进程崩溃

kill指令执行的是系统调用，由内核给指定进程发送信号：

1. 进程收到系统发的信号，CPU暂停运行，将控制权转移给os
2. 调用kill系统调用向进程发送信
3. 操作系统根据情况执行相应的信号处理程序

这个信号处理函数，一般系统有默认的信号处理程序，但如果用户程序注册了，则执行自己的信号处理函数。
















































